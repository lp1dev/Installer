#!/usr/bin/env bash

# ArchLabs Base Installer (version 1.2 - Feb, 2018)
# Modified and adapted by Nathaniel Maia for use in Archlabs
# Originally Written by Carl Duff for PacBang Linux
# This program is free software, provided under the GNU GPL

# Installation
ISO_USER="liveuser"               # Live user account
DIST="ArchLabs"                   # Distributor name for grub etc
VERSION="ArchLabs Installer 1.2"  # Installer Name / Version
ANS="/tmp/.archlabs-installer"    # Temp file to store answers
MNT="/mnt"                        # Installation mountpoint
ERR="/tmp/.errlog"                # error log file
IMG="/run/archiso/sfs/airootfs/"  # Squash image to install
BYPASS="$MNT/bypass/"             # Squash image mountpoint
MOUNT_OPTS="/tmp/.mnt_opts"       # file system mount options
CMAP="us"                         # Default virtual console keymap
XMAP="us"                         # Default X11 keyboard layout
LOC="en_US.UTF-8"                 # Default system locale
ARCHI=$(uname -m)                 # Display whether 32 or 64 bit system
SYSTEM="Unknown"                  # Default for BIOS or UEFI.
EFI_MNT="/boot/efi"               # EFI partition mountpoint
MHIGHLIGHT=0                      # Highlight items for Main Menu
HIGHLIGHT=0                       # Highlight items for submenus
SUB_MENU=""                       # Submenu to be highlighted
FS_OPTS=""                        # FS mount options available
CHK_NUM=16                        # Default mount options checklist length
LVM=0                             # Logical Volume Management Detected?
LVM_SEP_BOOT=0                    # 1 = Seperate /boot, 2 = seperate /boot & LVM
LV_VG=""                          # Name of volume group to create or use
LV_VG_MB=0                        # MB remaining of VG
LV_NAME=""                        # Name of LV to create or use
LV_SIZE_INVALID=0                 # Is LVM LV size entered valid?
VG_SIZE_TYPE=""                   # Is VG in Gigabytes or Megabytes?
LUKS=0                            # Luks Detected?
LUKS_DEV=""                       # If encrypted, partition
LUKS_NAME=""                      # Name given to encrypted partition
LUKS_UUID=""                      # UUID used for comparison purposes

select_language() {
    dialog --backtitle "$BTITLE" --title " Select Language " --menu \
        "Language / sprache / taal / språk / lingua / idioma / nyelv / língua" 0 0 9 \
        "1" $"English            (en_**)" "2" $"Español            (es_ES)" \
        "3" $"Português [Brasil] (pt_BR)" "4" $"Português          (pt_PT)" \
        "5" $"Français           (fr_FR)" "6" $"Russkiy            (ru_RU)" \
        "7" $"Italiano           (it_IT)" "8" $"Nederlands         (nl_NL)" \
        "9" $"Magyar             (hu_HU)" 2>$ANS
    case "$(cat $ANS)" in
        "1") source /archlabs-installer/english.trans    ; LOC="en_US.UTF-8" ;;
        "2") source /archlabs-installer/spanish.trans    ; LOC="es_ES.UTF-8" ;;
        "3") source /archlabs-installer/p_brasil.trans   ; LOC="pt_BR.UTF-8" ;;
        "4") source /archlabs-installer/portuguese.trans ; LOC="pt_PT.UTF-8" ;;
        "5") source /archlabs-installer/french.trans     ; LOC="fr_FR.UTF-8" ;;
        "6") source /archlabs-installer/russian.trans    ; LOC="ru_RU.UTF-8" ;;
        "7") source /archlabs-installer/italian.trans    ; LOC="it_IT.UTF-8" ;;
        "8") source /archlabs-installer/dutch.trans      ; LOC="nl_NL.UTF-8" ;;
        "9") source /archlabs-installer/hungarian.trans  ; LOC="hu_HU.UTF-8" ;;
        *) exit 0
    esac
    # Always enable en_US
    sed -i "s/#en_US.UTF-8/en_US.UTF-8/" /etc/locale.gen

    if [[ $LOC != "en_US.UTF-8" ]]; then
        sed -i "s/#${LOC}/${LOC}/" /etc/locale.gen
    fi
    locale-gen >/dev/null 2>&1
    export LANG="$LOC"
}

check_requirements() {
    dialog --backtitle "$BTITLE" --title " $_ChkTitle " --infobox "$_ChkBody" 0 0 ; sleep 2
    if [[ $(whoami) != "root" ]]; then
        dialog --backtitle "$BTITLE" --title " $_ErrTitle " --infobox "$_RtFailBody" 0 0
        sleep 2 ; exit 1
    fi
    if [[ ! $(ping -c 1 google.com) ]]; then
        dialog --backtitle "$BTITLE" --title " $_ErrTitle " --infobox "$_ConFailBody" 0 0
        sleep 2 ; exit 1
    fi
    dialog --backtitle "$BTITLE" --title " $_ReqMetTitle " --infobox "$_ReqMetBody" 0 0
    sleep 2 ; clear ; echo "" >"$ERR"
}

id_system() {
    if grep -q 'Apple' /sys/class/dmi/id/sys_vendor; then
        modprobe -r -q efivars || true
    else
        modprobe -q efivarfs
    fi
    if [[ -d "/sys/firmware/efi/" ]]; then
        if grep -q /sys/firmware/efi/efivars <<< "$(mount)"; then
            mount -t efivarfs efivarfs /sys/firmware/efi/efivars
        fi
        SYSTEM="UEFI"
    else
        SYSTEM="BIOS"
    fi
    BTITLE="$VERSION - $SYSTEM ($ARCHI)"
}

arch_chroot() {
    arch-chroot $MNT /bin/bash -c "$1"
}

check_for_error() {
    if [[ $? -eq 1 ]] && grep -wqi "error" "$ERR"; then
        MSG=$(cat "$ERR")
        dialog --backtitle "$BTITLE" --title " $_ErrTitle " --msgbox "$MSG" 0 0
        rm -rf ${MNT:?}/* ; main_menu
    fi
}

check_mount() {
    if ! grep -q "$MNT" <<< "$(lsblk -o MOUNTPOINT)"; then
        dialog --backtitle "$BTITLE" --title " $_ErrTitle " --msgbox "$_ErrNoMount" 0 0
        main_menu
    fi
}

check_base() {
    if ! [[ -e $MNT/etc ]]; then
        dialog --backtitle "$BTITLE" --title " $_ErrTitle " --msgbox "$_ErrNoBase" 0 0
        main_menu
    fi
}

show_devices() {
    lsblk -o NAME,MODEL,TYPE,FSTYPE,SIZE,MOUNTPOINT \
        | grep "disk\|part\|lvm\|crypt\|NAME\|TYPE\|SIZE" >/tmp/.devlist
    dialog --backtitle "$BTITLE" --title " $_DevShowOpt " --textbox /tmp/.devlist 0 0
}

set_keymap() {
    CMAPS=""
    local maps
    maps=$(ls -R /usr/share/kbd/keymaps)
    maps=$(sed 's/\.map\.gz//g' <<< "$(grep "map.gz" <<< "$maps")")
    for i in $(sort <<< "$maps"); do CMAPS="$CMAPS $i -" ; done
    dialog --backtitle "$BTITLE" --title " $_VCKeymapTitle " \
        --menu "$_VCKeymapBody" 20 40 16 $CMAPS 2>$ANS || prep_menu
    CMAP=$(cat $ANS)
    echo -e "KEYMAP=$CMAP\nFONT=$FONT" > /tmp/vconsole.conf
}

set_xkbmap() {
    XMAPS=""
    local maps
    maps=(af al am at az ba bd be bg br bt bw by ca cd ch cm cn cz de dk ee es et
          eu 'fi' fo fr gb ge gh gn gr hr hu ie il in iq ir is it jp ke kg kh kr
          kz la lk lt lv ma md me mk ml mm mn mt mv ng nl no np pc ph pk pl pt ro
          rs ru se si sk sn sy tg th tj tm tr tw tz ua us uz vn za)
    for i in "${maps[@]}"; do XMAPS="$XMAPS $i -" ; done
    dialog --backtitle "$BTITLE" --title " $_PrepKBLayout " \
        --menu "$_XkbmapBody" 0 0 16 $XMAPS 2>$ANS || prep_menu
    XMAP=$(sed 's/_.*//' "$ANS")

    KFILE='Section "InputClass"\n\tIdentifier "system-keyboard"\n\tMatchIsKeyboard "on"'
    KFILE="$KFILE\n\tOption \"XkbLayout\" \"$XMAP\"\nEndSection"
    echo -e "$KFILE" > /tmp/01-keyboard-layout.conf

    setxkbmap "$XMAP" 2>>"$ERR"
    check_for_error

    DKFILE='# KEYBOARD CONFIGURATION FILE\n\nConsult the keyboard(5) manual page.'
    DKFILE="$DKFILE\n\nXKBMODEL=\"\"\nXKBLAYOUT=\"$XMAP\"\nXKBVARIANT=\"\""
    DKFILE="$DKFILE\nXKBOPTIONS=\"\"\nBACKSPACE=\"guess\""
    echo -e "$DKFILE" > /tmp/keyboard
}

set_locale() {
    LOCS=""
    LOCL=$(sed 's/ UTF-8//g' <<< "$(sed 's/#//g' <<< "$(grep -v "#  " /etc/locale.gen)")")
    for i in $(grep .UTF-8 <<< "$LOCL"); do LOCS="$LOCS $i -" ; done
    dialog --backtitle "$BTITLE" --title " $_ConfBseSysLoc " \
        --menu "$_localeBody" 0 0 12 $LOCS 2>$ANS || config_base_menu
    LOC=$(cat $ANS)
    sed -i "s/en_US.UTF-8/${LOC}/g" $MNT/etc/locale.conf
    cp -f $MNT/etc/locale.conf $MNT/etc/default/locale
    sed -i "s/#${LOC}/${LOC}/g" $MNT/etc/locale.gen
    sed -i "s/en_US.UTF-8/${LOC}/g" $MNT/etc/default/locale
    arch_chroot "locale-gen" >/dev/null 2>>"$ERR"
    check_for_error
}

set_timezone() {
    ZONE="" SUBZONE="" Z_FULL=$(awk '{print $3}' < /usr/share/zoneinfo/zone.tab)
    for i in $(grep "/" <<< "$Z_FULL" | sed "s/\/.*//g" | sort -ud); do
        ZONE="$ZONE $i -"
    done
    dialog --backtitle "$BTITLE" --title " $_ConfBseTimeHC " \
        --menu "$_TimeZBody" 0 0 10 $ZONE 2>$ANS || config_base_menu
    ZONE=$(cat $ANS)
    for i in $(grep "$ZONE/" <<< "$Z_FULL" | sed "s/${ZONE}\///g" | sort -ud); do
        SUBZONE="$SUBZONE $i -"
    done
    dialog --backtitle "$BTITLE" --title " $_ConfBseTimeHC " \
        --menu "$_TimeSubZBody" 0 0 11 $SUBZONE 2>$ANS || config_base_menu
    SUBZONE=$(cat $ANS)
    local MSG="$_TimeZQ $ZONE/$SUBZONE?\n"
    if dialog --backtitle "$BTITLE" --title " $_ConfBseTimeHC " --yesno "$MSG" 0 0; then
        arch_chroot "ln -sf /usr/share/zoneinfo/$ZONE/$SUBZONE /etc/localtime" 2>>"$ERR"
        check_for_error
    else
        config_base_menu
    fi
}

set_hw_clock() {
    dialog --backtitle "$BTITLE" --title " $_ConfBseTimeHC " --menu "$_HwCBody" 0 0 2 \
        "utc" "-" \
        "localtime" "-" 2>$ANS
    [[ $(cat $ANS) != "" ]] && arch_chroot "hwclock --systohc --$(cat $ANS)" 2>>"$ERR"
    check_for_error
}

generate_fstab() {
    dialog --backtitle "$BTITLE" --title " $_ConfBseFstab " \
        --menu "$_FstabBody" 0 0 4 \
        "genfstab -p"             "$_FstabDevName" \
        "genfstab -L -p"          "$_FstabDevLabel" \
        "genfstab -U -p"          "$_FstabDevUUID" \
        "genfstab -t PARTUUID -p" "$_FstabDevPtUUID" 2>$ANS
    if [[ $(cat $ANS) != "" ]]; then
        if [[ $SYSTEM == "BIOS" ]] && [[ $(cat $ANS) == "genfstab -t PARTUUID -p" ]]; then
            dialog --backtitle "$BTITLE" --title " $_ErrTitle " --msgbox "$_FstabErr" 0 0
            generate_fstab
        else
            $(cat $ANS) $MNT > $MNT/etc/fstab 2>>"$ERR"
            check_for_error
            [[ -f $MNT/swapfile ]] && sed -i "s/\\${MNT}//" $MNT/etc/fstab
        fi
    fi
}

set_hostname() {
    HSTNM=$(awk '{print tolower($1)}' <<< "$DIST")
    dialog --backtitle "$BTITLE" --title "$_ConfBseHost" \
        --inputbox "$_HostNameBody" 0 0 "$HSTNM" 2>$ANS || config_base_menu
    HOST_NAME=$(cat $ANS)
    echo "$HOST_NAME" > $MNT/etc/hostname
    echo "127.0.0.1    localhost
127.0.1.1    $HOST_NAME
::1     localhost ip6-localhost ip6-loopback
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters" > $MNT/etc/hosts
}

set_root_password() {
    dialog --backtitle "$BTITLE" --title " $_ConfUsrRoot " --clear --insecure \
        --passwordbox "$_PassRtBody" 0 0 2> $ANS || config_base_menu
    PASSWD=$(cat $ANS)
    dialog --backtitle "$BTITLE" --title " $_ConfUsrRoot " --clear --insecure \
        --passwordbox "$_PassRtBody2" 0 0 2> $ANS || config_base_menu
    PASSWD2=$(cat $ANS)
    if [[ $PASSWD == "$PASSWD2" ]]; then
        echo -e "$PASSWD\n$PASSWD" >/tmp/.passwd
        arch_chroot "passwd root" </tmp/.passwd >/dev/null 2>>"$ERR"
        rm /tmp/.passwd
        check_for_error
    else
        dialog --backtitle "$BTITLE" --title " $_ErrTitle " --msgbox "$_PassErrBody" 0 0
        set_root_password
    fi
}


create_new_user() {
    dialog --backtitle "$BTITLE" --title " $_NUsrTitle " \
        --inputbox "$_NUsrBody" 0 0 "" 2>$ANS || config_base_menu
    USER=$(cat $ANS)

    # Loop while user name is invalid
    while [[ ${#USER} -eq 0 ]] || [[ $USER =~ \ |\' ]] || [[ $USER =~ [^a-z0-9\ ] ]]; do
        dialog --backtitle "$BTITLE" --title " $_NUsrTitle " \
            --inputbox "$_NUsrErrBody" 0 0 "" 2>$ANS || config_base_menu
        USER=$(cat $ANS)
    done

    dialog --backtitle "$BTITLE" --title " $_ConfUsrNew " --clear --insecure \
        --passwordbox "$_PassNUsrBody $USER" 0 0 2>$ANS || config_base_menu
    PASSWD=$(cat $ANS)
    dialog --backtitle "$BTITLE" --title " $_ConfUsrNew " --clear --insecure \
        --passwordbox "$_PassNUsrBody2 $USER" 0 0 2>$ANS || config_base_menu
    PASSWD2=$(cat $ANS)
    while [[ $PASSWD != "$PASSWD2" ]]; do
        dialog --backtitle "$BTITLE" --title " $_ErrTitle " --msgbox "$_PassErrBody" 0 0
        dialog --backtitle "$BTITLE" --title " $_ConfUsrNew " --clear --insecure \
            --passwordbox "$_PassNUsrBody $USER" 0 0 2>$ANS || config_base_menu
        PASSWD=$(cat $ANS)
        dialog --backtitle "$BTITLE" --title " $_ConfUsrNew " --clear --insecure \
            --passwordbox "$_PassNUsrBody2 $USER" 0 0 2>$ANS || config_base_menu
        PASSWD2=$(cat $ANS)
    done

    dialog --backtitle "$BTITLE" --title " $_ConfUsrNew " --infobox "$_NUsrSetBody" 0 0
    sleep 2 ; echo -e "$PASSWD\n$PASSWD" >/tmp/.passwd
    GROUP="rfkill,wheel,autologin,network,lp,storage,power,video,audio,lp"

    # If the first (or only) user account, then change the live account
    if [[ -e $MNT/home/$ISO_USER ]]; then
        arch_chroot "passwd $ISO_USER" </tmp/.passwd >/dev/null 2>>"$ERR"
        check_for_error

        WHEEL="%wheel ALL=(ALL) ALL"
        OPENBOX="$MNT/home/$ISO_USER/.config/openbox"
        L_FILES=(/etc/lightdm/lightdm.conf "/home/$ISO_USER/.config/openbox/autostart"
                 /etc/group /etc/gshadow /etc/passwd /etc/shadow)
        for f in "${L_FILES[@]}"; do
            sed -i "s/${ISO_USER}/${USER}/g" ${MNT}"$f"
        done
        sed -i '98,103d' $OPENBOX/menu.xml
        sed -i '743,745d' $OPENBOX/rc.xml
        sed -i 's/#$HOME/$HOME/g' $OPENBOX/autostart
        sed -i '/keypack/d' $OPENBOX/autostart
        rm -f  $MNT/home/$ISO_USER/.config/keypack
        sed -i '/al-hello/ c sleep 10; termite -e al-hello &' $OPENBOX/autostart
        # Swap live account
        {
            arch_chroot "mv /home/$ISO_USER /home/$USER"
            arch_chroot "chown -R $USER:users /home/$USER"
            arch_chroot "usermod -aG $GROUP $USER"
            sed -i "s/# ${WHEEL}/${WHEEL}/g" $MNT/etc/sudoers
        } 2>>"$ERR"
        check_for_error
    else
        {
            arch_chroot "useradd $USER -m -g users -G $GROUP -s /bin/zsh"
            arch_chroot "passwd $USER" < /tmp/.passwd >/dev/null
            arch_chroot "cp -R /etc/skel/ /home/$USER"
            arch_chroot "chown -R ${USER}:users /home/$USER"
        } 2>>"$ERR"
        check_for_error
    fi
    rm /tmp/.passwd
}

run_mkinitcpio() {
    clear
    local CONF="$MNT/etc/mkinitcpio.conf"
    if [[ $LVM -eq 1 ]] && [[ $LUKS -eq 0 ]]; then
        sed -i 's/block filesystems/block lvm2 filesystems/g' $CONF 2>>"$ERR"
    elif [[ $LVM -eq 1 ]] && [[ $LUKS -eq 1 ]]; then
        sed -i 's/block filesystems/block encrypt lvm2 filesystems/g' $CONF 2>>"$ERR"
    elif [[ $LVM -eq 0 ]] && [[ $LUKS -eq 1 ]]; then
        sed -i 's/block filesystems/block encrypt filesystems/g' $CONF 2>>"$ERR"
    fi
    if [[ $MNTHOOKS != "" ]]; then
        sed -i "s/keyboard fsck/keyboard ${MNTHOOKS} fsck/g" $CONF 2>>"$ERR"
    fi
    arch_chroot "mkinitcpio -p linux" 2>>"$ERR"
    check_for_error
}

######################################################################
##            System and Partitioning Functions                     ##
######################################################################

umount_partitions() {
    MOUNTED=""
    MOUNTED=($(mount | grep "$MNT" | awk '{print $3}' | sort -r))
    swapoff -a
    for i in "${MOUNTED[@]}"; do umount "$i" >/dev/null 2>>"$ERR" ; done
    check_for_error
}

confirm_mount() {
    local TITLE MSG
    TITLE=" $_MntStatusTitle "
    if grep -q "$1" <<< "$(mount)"; then
        dialog --backtitle "$BTITLE" --title "$TITLE" --infobox "$_MntStatusSucc" 0 0
        sleep 2
        PARTS=$(sed "s~${PART} [0-9]*[G-M]~~" <<< "$PARTS")
        PARTS=$(sed "s~${PART} [0-9]*\.[0-9]*[G-M]~~" <<< "$PARTS" | sed s~${PART}$' -'~~)
        NUM_PARTS=$((NUM_PARTS - 1))
    else
        dialog --backtitle "$BTITLE" --title "$TITLE" --infobox "$_MntStatusFail" 0 0
        sleep 2
        prep_menu
    fi
}

select_device() {
    DEVICE=""
    devs=$(grep 'disk' <<< "$(lsblk -lno NAME,SIZE,TYPE)")
    devs=$(awk '{print "/dev/" $1 " " $2}' <<< "$devs" | sort -u)
    for i in "${devs[@]}"; do DEVICE="$DEVICE $i" ; done
    dialog --backtitle "$BTITLE" --title " $_DevSelTitle " \
        --menu "$_DevSelBody" 0 0 4 $DEVICE 2>$ANS || prep_menu
    DEVICE=$(cat $ANS)
}

find_partitions() {
    PARTS=""
    NUM_PARTS=0
    LBLK=$(lsblk -lno NAME,SIZE,TYPE | grep "$INC_PART" | sed 's/part$/\/dev\//g')
    LBLK=$(sed 's/lvm$\|crypt$/\/dev\/mapper\//g' <<< "$LBLK")
    pts=$(awk '{print $3$1 " " $2}' <<< "$LBLK" | sort -u)
    for i in ${pts}; do PARTS="$PARTS $i" ; NUM_PARTS=$((NUM_PARTS + 1)) ; done
    NUM_PARTS=$((NUM_PARTS / 2))

    case $INC_PART in
        'part\|lvm\|crypt')
            if [[ $SYSTEM == "UEFI" ]] && [[ $NUM_PARTS -lt 2 ]]; then
                dialog --backtitle "$BTITLE" --title " $_ErrTitle " --msgbox "$_PartErrBody" 0 0
                create_partitions
            elif [[ $SYSTEM == "BIOS" ]] && [[ $NUM_PARTS -eq 0 ]]; then
                dialog --backtitle "$BTITLE" --title " $_ErrTitle " --msgbox "$_PartErrBody" 0 0
                create_partitions
            fi ;;
        'part\|crypt')
            if [[ $NUM_PARTS -eq 0 ]]; then
                dialog --backtitle "$BTITLE" --title " $_ErrTitle " --msgbox "$_LvmPartErrBody" 0 0
                create_partitions
            fi ;;
        'part\|lvm')
            if [[ $NUM_PARTS -lt 2 ]]; then
                dialog --backtitle "$BTITLE" --title " $_ErrTitle " --msgbox "$_LuksPartErrBody" 0 0
                create_partitions
            fi
    esac
}


create_partitions() {
    secure_wipe() {
        local MSG="$_AutoPartBody1 $DEVICE $_AutoPartBody2 $_AutoPartBody3"
        if dialog --backtitle "$BTITLE" --title " $_PartOptWipe " --yesno "$MSG" 0 0; then
            clear ; echo -e "Secure wiping $DEVICE this will take a while.."
            wipe -Ifre "$DEVICE"
        else
            create_partitions
        fi
    }

    auto_partition() {
        local MSG="$_AutoPartBody1 $DEVICE $_AutoPartBody2 $_AutoPartBody3"
        if dialog --backtitle "$BTITLE" --title " $_PrepPartDisk " --yesno "$MSG" 0 0; then
            parted -s "$DEVICE" print | awk '/^ / {print $1}' >/tmp/.del_parts
            for del_part in $(tac /tmp/.del_parts); do
                parted -s "$DEVICE" rm "$del_part" 2>>"$ERR"
                check_for_error
            done
            table=$(parted -s "$DEVICE" print | grep -i 'partition table' | awk '{print $3}')
            if ([[ $SYSTEM == "BIOS" ]] && [[ $table != "msdos" ]]); then
                parted -s "$DEVICE" mklabel msdos 2>>"$ERR"
            elif ([[ $SYSTEM == "UEFI" ]] && [[ $table != "gpt" ]]); then
                parted -s "$DEVICE" mklabel gpt 2>>"$ERR"
            fi
            check_for_error
            if [[ $SYSTEM == "BIOS" ]]; then
                parted -s "$DEVICE" mkpart primary ext4 1MiB 513MiB 2>>"$ERR"
            else
                parted -s "$DEVICE" mkpart ESP fat32 1MiB 513MiB 2>>"$ERR"
            fi
            parted -s "$DEVICE" set 1 boot on 2>>"$ERR"
            parted -s "$DEVICE" mkpart primary ext4 513MiB 100% 2>>"$ERR"
            check_for_error
            lsblk "$DEVICE" -o NAME,TYPE,FSTYPE,SIZE >/tmp/.devlist
            dialog --backtitle "$BTITLE" --title "" --textbox /tmp/.devlist 0 0
        else
            create_partitions
        fi
    }

    dialog --backtitle "$BTITLE" --title "$_PartToolTitle" --menu "$_PartToolBody" 0 0 5 \
        "$_PartOptWipe" "BIOS & UEFI" \
        "$_PartOptAuto" "BIOS & UEFI" \
        "gparted"       "BIOS & UEFI" \
        "cfdisk"        "BIOS/MBR" \
        "parted"        "UEFI/GPT" 2>$ANS
    clear
    if [[ $(cat $ANS) != "" ]]; then
        if [[ $(cat $ANS) != "$_PartOptWipe" ]] && [[ $(cat $ANS) != "$_PartOptAuto" ]]; then
            $(cat $ANS) "$DEVICE"
        else
            [[ $(cat $ANS) == "$_PartOptWipe" ]] && secure_wipe && create_partitions
            [[ $(cat $ANS) == "$_PartOptAuto" ]] && auto_partition
        fi
    fi
}

select_filesystem() {
    fs_opts="" CHK_NUM=0
    dialog --backtitle "$BTITLE" --title " $_FSTitle " --menu "$_FSBody" 0 0 12 \
        "$_FSSkip" "-" \
        "btrfs"    "mkfs.btrfs -f" \
        "ext2"     "mkfs.ext2 -q" \
        "ext3"     "mkfs.ext3 -q" \
        "ext4"     "mkfs.ext4 -q" \
        "f2fs"     "mkfs.f2fs" \
        "jfs"      "mkfs.jfs -q" \
        "nilfs2"   "mkfs.nilfs2 -q" \
        "ntfs"     "mkfs.ntfs -q" \
        "reiserfs" "mkfs.reiserfs -q" \
        "vfat"     "mkfs.vfat -F32" \
        "xfs"      "mkfs.xfs -f" 2>$ANS
    case "$(cat $ANS)" in
        "$_FSSkip")
            FS="$_FSSkip"
            ;;
        "btrfs")
            FS="mkfs.btrfs -f" CHK_NUM=16
            fs_opts=(autodefrag "compress=zlib" "compress=lzo" "compress=no"
                     "compress-force=zlib" "compress-force=lzo" discard noacl
                     noatime nodatasum nospace_cache recovery skip_balance
                     space_cache ssd ssd_spread)
            modprobe btrfs
            ;;
        "ext2")
            FS="mkfs.ext2 -q"
            ;;
        "ext3")
            FS="mkfs.ext3 -q"
            ;;
        "ext4")
            FS="mkfs.ext4 -q" CHK_NUM=8
            fs_opts=("data=journal" "data=writeback" dealloc discard
                      noacl noatime nobarrier nodelalloc)
            ;;
        "f2fs")
            FS="mkfs.f2fs" CHK_NUM=16
            fs_opts=(data_flush disable_roll_forward disable_ext_identify
                     discard fastboot flush_merge inline_xattr inline_data
                     inline_dentry no_heap noacl nobarrier noextent_cache
                     noinline_data norecovery)
            modprobe f2fs
            ;;
        "jfs")
            FS="mkfs.jfs -q" CHK_NUM=4
            fs_opts=(discard "errors=continue" "errors=panic" nointegrity)
            ;;
        "nilfs2")
            FS="mkfs.nilfs2 -q" CHK_NUM=7
            fs_opts=(discard nobarrier "errors=continue" "errors=panic"
                     "order=relaxed" "order=strict" norecovery)
            ;;
        "ntfs")
            FS="mkfs.ntfs -q"
            ;;
        "reiserfs")
            FS="mkfs.reiserfs -q" CHK_NUM=5
            fs_opts=(acl nolog notail replayonly user_xattr)
            ;;
        "vfat")
            FS="mkfs.vfat -F32"
            ;;
        "xfs")
            FS="mkfs.xfs -f" CHK_NUM=9
            fs_opts=(discard filestreams ikeep largeio noalign
                     nobarrier norecovery noquota wsync)
            ;;
        *) prep_menu
    esac
    if [[ $FS != "$_FSSkip" ]]; then
        MSG="\n$FS $PART\n\n"
        if dialog --backtitle "$BTITLE" --title " $_FSTitle " --yesno "$MSG" 0 0; then
            $FS "$PART" >/dev/null 2>>"$ERR"
            check_for_error
        else
            select_filesystem
        fi
    fi
}


mount_partitions() {

    mount_opts() {
        FS_OPTS=""
        local TITLE MSG
        echo "" > $MOUNT_OPTS
        for i in "${fs_opts[@]}"; do FS_OPTS="$FS_OPTS $i - off"; done
        TITLE=" $(sed "s/.*\.//g" <<< "$FS" | sed "s/-.*//g") "
        dialog --backtitle "$BTITLE" --title "$TITLE" \
            --checklist "$_MntBody" 0 0 $CHK_NUM $FS_OPTS 2>$MOUNT_OPTS
        sed -i 's/ /,/g' $MOUNT_OPTS && sed -i '$s/,$//' $MOUNT_OPTS
        if [[ $(cat $MOUNT_OPTS) != "" ]]; then
            MSG="${_MntConfBody}$(cat $MOUNT_OPTS)\n"
            TITLE=" $_MntStatusTitle "
            if ! dialog --backtitle "$BTITLE" --title "$TITLE" --yesno "$MSG" 10 75; then
                mount_opts
            fi
        fi
    }

    mount_current_partition() {
        mkdir -p "${MNT}$MOUNT" 2>>"$ERR"
        [[ ${fs_opts[*]} != "" ]] && mount_opts
        if [[ $(cat $MOUNT_OPTS) != "" ]]; then
            mount -o $(cat $MOUNT_OPTS) "$PART" "${MNT}$MOUNT" 2>>"$ERR"
        else
            mount "$PART" "${MNT}$MOUNT" 2>>"$ERR"
        fi
        check_for_error
        confirm_mount "${MNT}$MOUNT"

        # Identify if mounted partition is "crypt" (LUKS on LVM, or LUKS alone)
        local BLK
        BLK=$(lsblk -lno NAME,FSTYPE,TYPE)
        if grep -q "crypt" <<< "$(lsblk -lno TYPE "$PART")"; then
            LUKS=1 LUKS_NAME=$(sed "s~^/dev/mapper/~~g" <<< "$PART")
            BLK=$(grep "lvm" <<< "$BLK" | grep -i "crypto_luks")
            crypts=$(awk '{print "/dev/mapper/"$1}' <<< "$BLK" | uniq)
            for i in ${crypts}; do
                if grep -q "$LUKS_NAME" <<< "$(lsblk -lno NAME "$i")"; then
                    LUKS_DEV="$LUKS_DEV cryptdevice=$i:$LUKS_NAME" LVM=1
                    break
                fi
            done
            BLK=$(grep "part" <<< "$BLK" | grep -i "crypto_luks")
            crypts=$(awk '{print "/dev/"$1}' <<< "$BLK" | uniq)
            for i in ${crypts}; do
                if grep -q "$LUKS_NAME" <<< "$(lsblk -lno NAME "$i")"; then
                    UUID=$(lsblk -lno UUID,TYPE,FSTYPE "$i" | grep "part")
                    LUKS_UUID=$(grep -i "crypto_luks" <<< "$UUID" | awk '{print $1}')
                    LUKS_DEV="$LUKS_DEV cryptdevice=UUID=$LUKS_UUID:$LUKS_NAME"
                    break
                fi
            done
        elif grep -q "lvm" "$(lsblk -lno TYPE "$PART")"; then
            LVM=1 NAME=$(sed "s~^/dev/mapper/~~g" <<< "$PART")
            BLK=$(grep "crypt" <<< "$BLK" | grep -i "lvm2_member")
            crypts=$(awk '{print "/dev/mapper/"$1}' <<< "$BLK" | uniq)
            for i in ${crypts}; do
                if grep -q "$NAME" <<< "$(lsblk -lno NAME "$i")"; then
                    LUKS_NAME=$(sed s~/dev/mapper/~~g <<< "$i")
                    break
                fi
            done
            BLK=$(grep "part" <<< "$BLK" | grep -i "crypto_luks")
            crypts=$(awk '{print "/dev/"$1}' <<< "$BLK" | uniq)
            for i in ${crypts}; do
                if grep -q "$LUKS_NAME" <<< "$(lsblk -lno NAME "$i")"; then
                    UUID=$(lsblk -lno UUID,TYPE,FSTYPE "$i" | grep "part")
                    LUKS_UUID=$(grep -i "crypto_luks" <<< "$UUID" | awk '{print $1}')
                    if ! grep -q "$LUKS_UUID" <<< "$LUKS_DEV"; then
                        LUKS_DEV="$LUKS_DEV cryptdevice=UUID=$LUKS_UUID:$LUKS_NAME"
                        LUKS=1
                    fi
                    break
                fi
            done
        fi
    }


    make_swap() {
        dialog --backtitle "$BTITLE" --title " $_PrepMntPart " \
            --menu "$_SelSwpBody" 0 0 7 \
            "$_SelSwpNone" $"-" \
            "$_SelSwpFile" $"-" \
            $PARTS 2>$ANS || prep_menu
        if [[ $(cat $ANS) != "$_SelSwpNone" ]]; then
            PART=$(cat $ANS)
            if [[ $PART == "$_SelSwpFile" ]]; then
                mem=$(grep MemTotal /proc/meminfo | awk '{print $2/1024}' | sed 's/\..*//')
                dialog --backtitle "$BTITLE" --title " $_SelSwpFile " \
                    --inputbox "\nM = MB, G = GB\n" 9 30 "${mem}M" 2>$ANS || make_swap
                m_or_g=$(cat $ANS)
                while [[ $(echo ${m_or_g: -1} | grep "M\|G") == "" ]]; do
                    MSG="\n$_SelSwpFile $_ErrTitle: M = MB, G = GB\n\n"
                    dialog --backtitle "$BTITLE" --title " $_SelSwpFile " --msgbox "$MSG" 0 0
                    dialog --backtitle "$BTITLE" --title " $_SelSwpFile " \
                        --inputbox "\nM = MB, G = GB\n" 9 30 "${mem}M" 2>$ANS || make_swap
                    m_or_g=$(cat $ANS)
                done
                fallocate -l $m_or_g $MNT/swapfile 2>>"$ERR"
                chmod 600 $MNT/swapfile 2>>"$ERR"
                mkswap $MNT/swapfile 2>>"$ERR"
                swapon $MNT/swapfile 2>>"$ERR"
                check_for_error
            else
                if [[ $(lsblk -o FSTYPE "$PART" | grep -i "swap") != "swap" ]]; then
                    TITLE=" $_PrepMntPart " MSG="\nmkswap $PART\n\n"
                    if dialog --backtitle "$BTITLE" --title "$TITLE" --yesno "$MSG" 0 0; then
                        mkswap "$PART" >/dev/null 2>>"$ERR"
                    else
                        mount_partitions
                    fi
                fi
                swapon "$PART" >/dev/null 2>>"$ERR"
                check_for_error
                PARTS=$(sed "s~${PART} [0-9]*[G-M]~~" <<< "$PARTS")
                PARTS=$(sed "s~${PART} [0-9]*\.[0-9]*[G-M]~~" <<< "$PARTS" | sed s~${PART}$' -'~~)
                NUM_PARTS=$((NUM_PARTS - 1))
            fi
        fi
    }

    #                                            #
    #  Find partitions and run mounting dialogs  #
    #                                            #

    MOUNT="" LUKS_NAME="" LUKS_DEV="" LUKS_UUID="" LUKS=0 LVM=0
    dialog --backtitle "$BTITLE" --title " $_PrepMntPart " \
        --msgbox "$_WarnMount1 '$_FSSkip' $_WarnMount2" 0 0
    lvm_detect
    INC_PART='part\|lvm\|crypt'
    umount_partitions
    find_partitions
    dialog --backtitle "$BTITLE" --title " $_PrepMntPart " \
        --menu "$_SelRootBody" 0 0 7 $PARTS 2>$ANS || prep_menu
    PART=$(cat $ANS)
    ROOT_PART=$PART
    select_filesystem
    mount_current_partition
    make_swap

    # Extra Step for VFAT EFI Partition.. Not in an LVM container.
    if [[ $SYSTEM == "UEFI" ]]; then
        dialog --backtitle "$BTITLE" --title " $_PrepMntPart " \
            --menu "$_SelUefiBody" 0 0 7 $PARTS 2>$ANS || prep_menu
        PART=$(cat $ANS)
        if ! grep -q 'fat' <<< "$(fsck -N "$PART")"; then
            mkfs.vfat -F32 "$PART" >/dev/null 2>>"$ERR"
        else
            FORMAT="True"
        fi
        check_for_error
        mkdir -p ${MNT}$EFI_MNT 2>>"$ERR"
        mount "$PART" ${MNT}$EFI_MNT 2>>"$ERR"
        check_for_error
        if [[ $FORMAT == "True" ]]; then
            LDR=$(find ${MNT}$EFI_MNT/EFI -maxdepth 1 -type d)
            if ! grep -qi "Windows\|Microsoft" <<< "$LDR"; then
                local MSG="$_FormUefiBody $PART $_FormUefiBody2"
                local TITLE=" $_PrepMntPart "
                if dialog --backtitle "$BTITLE" --title "$TITLE" --yesno "$MSG" 0 0; then
                    umount "$PART" ${MNT}$EFI_MNT &>/dev/null
                    mkfs.vfat -F32 "$PART" >/dev/null 2>>"$ERR"
                    mount "$PART" ${MNT}$EFI_MNT 2>>"$ERR"
                    check_for_error
                fi
            fi
        fi
        confirm_mount ${MNT}$EFI_MNT
    fi

    # leftover partitions
    while [[ $NUM_PARTS -gt 0 ]]; do
        dialog --backtitle "$BTITLE" --title " $_PrepMntPart " \
            --menu "$_ExtPartBody" 0 0 7 "$_Done" $"-" $PARTS 2>$ANS || prep_menu
        PART=$(cat $ANS)
        if [[ $PART == "$_Done" ]]; then
            break
        else
            MOUNT=""
            select_filesystem
            if [[ $SYSTEM == "UEFI" ]]; then
                MNT_EXAMPLES="/home /var"
            else
                MNT_EXAMPLES="/boot /home /var"
            fi
            dialog --backtitle "$BTITLE" --title " $_PrepMntPart $PARTITON " \
                --inputbox "$_ExtPartBody1$MNT_EXAMPLES\n" 0 0 "/" 2>$ANS || prep_menu
            MOUNT=$(cat $ANS)
            while [[ ${MOUNT:0:1} != "/" ]] || [[ ${#MOUNT} -le 1 ]] || [[ $MOUNT =~ \ |\' ]]; do
                dialog --backtitle "$BTITLE" --title " $_ErrTitle " --msgbox "$_ExtErrBody" 0 0
                dialog --backtitle "$BTITLE" --title " $_PrepMntPart $PARTITON " \
                    --inputbox "${_ExtPartBody1}$MNT_EXAMPLES\n" 0 0 "/" 2>$ANS || prep_menu
                MOUNT=$(cat $ANS)
            done
            mount_current_partition
            [[ $MOUNT == "/usr" ]] && MNTHOOKS="usr shutdown"
            if [[ $MOUNT == "/boot" ]]; then
                if grep -q "lvm" <<< "$(lsblk -lno TYPE "$PART")"; then
                    LVM_SEP_BOOT=2
                else
                    LVM_SEP_BOOT=1
                fi
            fi
        fi
    done
}

######################################################################
##             Encryption (dm_crypt) Functions                      ##
######################################################################

luks_password() {
    dialog --backtitle "$BTITLE" --title " $_PrepLUKS " --clear --insecure \
        --passwordbox "$_LuksPassBody" 0 0 2> $ANS || prep_menu
    PASSWD=$(cat $ANS)
    dialog --backtitle "$BTITLE" --title " $_PrepLUKS " --clear --insecure \
        --passwordbox "$_PassNUsrBody2 $LUKS_ROOT_NAME" 0 0 2> $ANS || prep_menu
    PASSWD2=$(cat $ANS)
    if [[ $PASSWD != "$PASSWD2" ]]; then
        dialog --backtitle "$BTITLE" --title " $_ErrTitle " --msgbox "$_PassErrBody" 0 0
        luks_password
    fi
}

luks_open() {
    LUKS_ROOT_NAME="" INC_PART='part\|crypt\|lvm'
    umount_partitions
    find_partitions
    dialog --backtitle "$BTITLE" --title " $_LuksOpen " \
        --menu "$_LuksMenuBody" 0 0 7 $PARTS 2>$ANS || luks_menu
    PART=$(cat $ANS)
    dialog --backtitle "$BTITLE" --title " $_LuksOpen " \
        --inputbox "$_LuksOpenBody" 10 50 "cryptroot" 2>$ANS || luks_menu
    LUKS_ROOT_NAME=$(cat $ANS)
    luks_password
    dialog --backtitle "$BTITLE" --title " $_LuksOpen " --infobox "$_PlsWaitBody" 0 0
    echo "$PASSWD" | cryptsetup open --type luks "$PART" "$LUKS_ROOT_NAME" 2>"$ERR"
    check_for_error
    lsblk -o NAME,TYPE,FSTYPE,SIZE,MOUNTPOINT "$PART" \
        | grep "crypt\|NAME\|MODEL\|TYPE\|FSTYPE\|SIZE" > /tmp/.devlist
    dialog --backtitle "$BTITLE" --title " $_DevShowOpt " --textbox /tmp/.devlist 0 0
    luks_menu
}

luks_setup() {
    modprobe -a dm-mod dm_crypt
    INC_PART='part\|lvm'
    umount_partitions
    find_partitions
    dialog --backtitle "$BTITLE" --title " $_LuksEncrypt " \
        --menu "$_LuksEncryptBody" 0 0 7 $PARTS 2>$ANS || luks_menu
    PART=$(cat $ANS)
    dialog --backtitle "$BTITLE" --title " $_LuksEncrypt " \
        --inputbox "$_LuksOpenBody" 10 50 "cryptroot" 2>$ANS || luks_menu
    LUKS_ROOT_NAME=$(cat $ANS)
    luks_password
}

luks_default() {
    dialog --backtitle "$BTITLE" --title " $_LuksEncrypt " --infobox "$_PlsWaitBody" 0 0
    sleep 2 ; echo "$PASSWD" | cryptsetup -q luksFormat "$PART" 2>"$ERR"
    echo "$PASSWD" | cryptsetup open "$PART" "$LUKS_ROOT_NAME" 2>"$ERR"
    check_for_error
}

luks_key_define() {
    dialog --backtitle "$BTITLE" --title " $_PrepLUKS " \
        --inputbox "$_LuksCipherKey" 0 0 "-s 512 -c aes-xts-plain64" 2>$ANS || luks_menu
    dialog --backtitle "$BTITLE" --title " $_LuksEncryptAdv " --infobox "$_PlsWaitBody" 0 0
    sleep 2
    echo "$PASSWD" | cryptsetup -q "$(cat $ANS)" luksFormat "$PART" 2>"$ERR"
    check_for_error
    echo "$PASSWD" | cryptsetup open "$PART" "$LUKS_ROOT_NAME" 2>"$ERR"
    check_for_error

}

luks_show(){
    echo -e "$_LuksEncryptSucc" >/tmp/.devlist
    lsblk -o NAME,TYPE,FSTYPE,SIZE "$PART" \
        | grep "part\|crypt\|NAME\|TYPE\|FSTYPE\|SIZE" >>/tmp/.devlist
    dialog --backtitle "$BTITLE" --title " $_LuksEncrypt " --textbox /tmp/.devlist 0 0
    luks_menu
}

luks_menu() {
    local MSG="$_LuksMenuBody$_LuksMenuBody2$_LuksMenuBody3"
    dialog --backtitle "$BTITLE" --title " $_PrepLUKS " --menu "$MSG" 0 0 4 \
        "$_LuksOpen"       "cryptsetup open --type luks" \
        "$_LuksEncrypt"    "cryptsetup -q luksFormat" \
        "$_LuksEncryptAdv" "cryptsetup -q -s -c luksFormat" \
        "$_Back" "-" 2>$ANS
    case "$(cat $ANS)" in
        "$_LuksOpen") luks_open ;;
        "$_LuksEncrypt") luks_setup ; luks_default ; luks_show ;;
        "$_LuksEncryptAdv") luks_setup ; luks_key_define ; luks_show ;;
        *) prep_menu
    esac
    luks_menu
}

######################################################################
##             Logical Volume Management Functions                  ##
######################################################################

lvm_detect() {
    LVM_PV=$(pvs -o pv_name --noheading 2>/dev/null)
    LV_VG=$(vgs -o vg_name --noheading 2>/dev/null)
    LV=$(lvs -o vg_name,lv_name --noheading --separator - 2>/dev/null)
    if [[ $LV != "" ]] && [[ $LV_VG != "" ]] && [[ $LVM_PV != "" ]]; then
        dialog --backtitle "$BTITLE" --title " $_PrepLVM " --infobox "$_LvmDetBody" 0 0
        modprobe dm-mod 2>>"$ERR"
        check_for_error
        vgscan >/dev/null 2>&1
        vgchange -ay >/dev/null 2>&1
    fi
}

lvm_show_vg() {
    VG_LIST=""
    vg_list=$(lvs --noheadings | awk '{print $2}' | uniq)
    for i in $vg_list; do
        VG_LIST="$VG_LIST $i $(vgdisplay "$i" | grep -i "vg size" | awk '{print $3$4}')"
    done
    if [[ $VG_LIST == "" ]]; then
        dialog --backtitle "$BTITLE" --title " $_ErrTitle " --msgbox "$_LvmVGErr" 0 0
        lvm_menu
    fi
    dialog --backtitle "$BTITLE" --title " $_PrepLVM " \
        --menu "$_LvmSelVGBody" 0 0 5 $VG_LIST 2>$ANS || lvm_menu
}

lvm_create() {
    check_lv_size() {
        chars=0
        LV_SIZE_INVALID=0
        LESS1=$((${#LV_SIZE} - 1))
        if [[ ${#LV_SIZE} -eq 0 ]] || [[ ${LV_SIZE:0:1} -eq "0" ]]; then
            LV_SIZE_INVALID=1
        fi
        if [[ $LV_SIZE_INVALID -eq 0 ]]; then
            while [[ $chars -lt $LESS1 ]]; do
                [[ ${LV_SIZE:chars:1} != [0-9] ]] && LV_SIZE_INVALID=1 && break
                chars=$((chars + 1))
            done
        fi
        if [[ $LV_SIZE_INVALID -eq 0 ]]; then
            LV_SIZE_TYPE=${LV_SIZE:$LESS1:1}
            case $LV_SIZE_TYPE in
                "m"|"M"|"g"|"G") LV_SIZE_INVALID=0 ;;
                *) LV_SIZE_INVALID=1
            esac
        fi
        if [[ $LV_SIZE_INVALID -eq 0 ]]; then
            case $LV_SIZE_TYPE in
                "G"|"g")
                    if [[ $((${LV_SIZE:0:$LESS1} * 1000)) -ge $LV_VG_MB ]]; then
                        LV_SIZE_INVALID=1
                    else
                        LV_VG_MB=$((LV_VG_MB - $((${LV_SIZE:0:$LESS1} * 1000))))
                    fi ;;
                "M"|"m")
                    if [[ ${LV_SIZE:0:$LESS1} -ge $LV_VG_MB ]]; then
                        LV_SIZE_INVALID=1
                    else
                        LV_VG_MB=$((LV_VG_MB - ${LV_SIZE:0:$LESS1}))
                    fi ;;
                *) LV_SIZE_INVALID=1
            esac
        fi
    }


    LV_VG="" VG_PARTS="" LV_VG_MB=0 INC_PART='part\|crypt'
    umount_partitions
    find_partitions
    PARTS=$(sed 's/M\|G\|T/& off/g' <<< "$PARTS")
    dialog --backtitle "$BTITLE" --title " $_LvmCreateVG " \
        --inputbox "$_LvmNameVgBody" 0 0 "" 2>$ANS || prep_menu
    LV_VG=$(cat $ANS)

    HAS_VG=$(grep -q "$LV_VG" <<< "$(lsblk)")
    while [[ ${LV_VG:0:1} == "/" ]] || [[ ${#LV_VG} -eq 0 ]] || [[ $LV_VG =~ \ |\' ]] || [[ $HAS_VG ]]; do
        dialog --backtitle "$BTITLE" --title "$_ErrTitle" --msgbox "$_LvmNameVgErr" 0 0
        dialog --backtitle "$BTITLE" --title " $_LvmCreateVG " \
            --inputbox "$_LvmNameVgBody" 0 0 "" 2>$ANS || prep_menu
        LV_VG=$(cat $ANS)
    done

    local MSG="$_LvmPvSelBody $_UseSpaceBar"
    dialog --backtitle "$BTITLE" --title " $_LvmCreateVG " \
        --checklist "$MSG" 0 0 7 $PARTS 2>$ANS || prep_menu
    [[ $(cat $ANS) != "" ]] && VG_PARTS=$(cat $ANS) || prep_menu

    MSG="$_LvmPvConfBody1${LV_VG} $_LvmPvConfBody2${VG_PARTS}"
    if dialog --backtitle "$BTITLE" --title " $_LvmCreateVG " --yesno "$MSG" 0 0; then
        MSG="$_LvmPvActBody1${LV_VG}.$_PlsWaitBody"
        dialog --backtitle "$BTITLE" --title " $_LvmCreateVG " --infobox "$MSG" 0 0
        sleep 1 ; vgcreate -f "$LV_VG" "$VG_PARTS" >/dev/null 2>>"$ERR"
        check_for_error
        VG_SIZE=$(vgdisplay "$LV_VG" | grep 'VG Size' | awk '{print $3}' | sed 's/\..*//')
        VG_SIZE_TYPE=$(vgdisplay "$LV_VG" | grep 'VG Size' | awk '{print $4}')
        [[ ${VG_SIZE_TYPE:0:1} == "G" ]] && LV_VG_MB=$((VG_SIZE * 1000)) || LV_VG_MB=$VG_SIZE
        MSG="$_LvmPvDoneBody1 '$LV_VG' $_LvmPvDoneBody2 ($VG_SIZE $VG_SIZE_TYPE)."
        dialog --backtitle "$BTITLE" --title " $_LvmCreateVG " --msgbox "$MSG" 0 0
    else
        lvm_menu
    fi

    MSG="$_LvmLvNumBody1 $LV_VG. $_LvmLvNumBody2"
    dialog --backtitle "$BTITLE" --title " $_LvmCreateVG " --radiolist "$MSG" 0 0 9 \
        "1" "-" off \
        "2" "-" off \
        "3" "-" off \
        "4" "-" off \
        "5" "-" off \
        "6" "-" off \
        "7" "-" off \
        "8" "-" off \
        "9" "-" off 2>$ANS
    [[ $(cat $ANS) == "" ]] && lvm_menu || NUM_LVS=$(cat $ANS)
    while [[ $NUM_LVS -gt 1 ]]; do
        TITLE=" $_LvmCreateVG (LV:$NUM_LVS) "
        dialog --backtitle "$BTITLE" --title "$TITLE" \
            --inputbox "$_LvmLvNameBody1" 0 0 "lvol" 2>$ANS || prep_menu
        LV_NAME=$(cat $ANS)

        HAS_LV=$(grep -q "$LV_NAME" <<< "$(lsblk)")
        while [[ ${LV_NAME:0:1} == "/" ]] || [[ ${#LV_NAME} -eq 0 ]] || [[ $LV_NAME =~ \ |\' ]] || [[ $HAS_LV ]]; do
            dialog --backtitle "$BTITLE" --title " $_ErrTitle " --msgbox "$_LvmLvNameErrBody" 0 0
            TITLE=" $_LvmCreateVG (LV:$NUM_LVS) "
            dialog --backtitle "$BTITLE" --title "$TITLE" \
                --inputbox "$_LvmLvNameBody1" 0 0 "lvol" 2>$ANS || prep_menu
            LV_NAME=$(cat $ANS)
        done

        MSG="${LV_VG}: ${VG_SIZE}$VG_SIZE_TYPE (${LV_VG_MB}MB $_LvmLvSizeBody1).$_LvmLvSizeBody2"
        TITLE=" $_LvmCreateVG (LV:$NUM_LVS) "
        dialog --backtitle "$BTITLE" --title "$TITLE" --inputbox "$MSG" 0 0 "" 2>$ANS || prep_menu
        LV_SIZE=$(cat $ANS)
        check_lv_size

        while [[ $LV_SIZE_INVALID -eq 1 ]]; do
            dialog --backtitle "$BTITLE" --title " $_ErrTitle " --msgbox "$_LvmLvSizeErrBody" 0 0
            TITLE=" $_LvmCreateVG (LV:$NUM_LVS) "
            MSG="${LV_VG}: ${VG_SIZE}$VG_SIZE_TYPE (${LV_VG_MB}MB $_LvmLvSizeBody1).$_LvmLvSizeBody2"
            dialog --backtitle "$BTITLE" --title "$TITLE" --inputbox "$MSG" 0 0 "" 2>$ANS || prep_menu
            LV_SIZE=$(cat $ANS)
            check_lv_size
        done

        lvcreate -L "$LV_SIZE" "$LV_VG" -n "$LV_NAME" 2>>"$ERR"
        check_for_error
        MSG="$_Done LV $LV_NAME ($LV_SIZE) $_LvmPvDoneBody2."
        dialog --backtitle "$BTITLE" --title " $_LvmCreateVG (LV:$NUM_LVS) " --msgbox "$MSG" 0 0
        NUM_LVS=$((NUM_LVS - 1))
    done

    TITLE=" $_LvmCreateVG (LV:$NUM_LVS) "
    MSG="$_LvmLvNameBody1 $_LvmLvNameBody2 (${LV_VG_MB}MB)." 0 0 "lvol"
    dialog --backtitle "$BTITLE" --title "$TITLE" --inputbox "$MSG" 2>$ANS || prep_menu
    LV_NAME=$(cat $ANS)

    HAS_LV=$(grep -q "$LV_NAME" <<< "$(lsblk)")
    while [[ ${LV_NAME:0:1} == "/" ]] || [[ ${#LV_NAME} -eq 0 ]] || [[ $LV_NAME =~ \ |\' ]] || [[ $HAS_LV ]]; do
        dialog --backtitle "$BTITLE" --title " $_ErrTitle " --msgbox "$_LvmLvNameErrBody" 0 0
        TITLE=" $_LvmCreateVG (LV:$NUM_LVS) "
        MSG="$_LvmLvNameBody1 $_LvmLvNameBody2 (${LV_VG_MB}MB)."
        dialog --backtitle "$BTITLE" --title "$TITLE" --inputbox "$MSG" 0 0 "lvol" 2>$ANS || prep_menu
        LV_NAME=$(cat $ANS)
    done

    lvcreate -l +100%FREE "$LV_VG" -n "$LV_NAME" 2>>"$ERR"
    check_for_error
    NUM_LVS=$((NUM_LVS - 1)) LVM=1
    dialog --backtitle "$BTITLE" --title " $_LvmCreateVG " \
        --yesno "$_LvmCompBody" 0 0 && show_devices || lvm_menu
}

lvm_del_vg() {
    lvm_show_vg
    if dialog --backtitle "$BTITLE" --title " $_LvmDelVG " --yesno "$_LvmDelQ" 0 0; then
        vgremove -f "$(cat $ANS)" >/dev/null 2>&1
    fi
    lvm_menu
}

lvm_del_all() {
    LVM_PV=$(pvs -o pv_name --noheading 2>/dev/null)
    LV_VG=$(vgs -o vg_name --noheading 2>/dev/null)
    LV=$(lvs -o vg_name,lv_name --noheading --separator - 2>/dev/null)
    if dialog --backtitle "$BTITLE" --title " $_LvMDelAll " --yesno "$_LvmDelQ" 0 0; then
        for i in $LV; do lvremove -f "/dev/mapper/$i" >/dev/null 2>&1; done
        for i in $LV_VG; do vgremove -f "$i" >/dev/null 2>&1; done
        for i in $LVM_PV; do pvremove -f "$i" >/dev/null 2>&1; done
    fi
    lvm_menu
}

lvm_menu() {
    dialog --backtitle "$BTITLE" --title " $_PrepLVM " --infobox "$_PlsWaitBody" 0 0
    sleep 1 ; lvm_detect
    dialog --backtitle "$BTITLE" --title " $_PrepLVM " --menu "$_LvmMenu" 0 0 4 \
        "$_LvmCreateVG" "vgcreate -f, lvcreate -L -n" \
        "$_LvmDelVG"    "vgremove -f" \
        "$_LvMDelAll"   "lvrmeove, vgremove, pvremove -f" \
        "$_Back" "-" 2>$ANS
    case "$(cat $ANS)" in
        "$_LvmCreateVG") lvm_create  ;;
        "$_LvmDelVG")    lvm_del_vg  ;;
        "$_LvMDelAll")   lvm_del_all ;;
        *)               prep_menu
    esac
}


######################################################################
##                    Installation Functions                        ##
######################################################################

install_root() {
    clear
    if [[ -e $IMG ]]; then
        rsync -a --progress $IMG $MNT/ 2>>"$ERR"
        check_for_error
    else
        echo -e "IMG has not been properly configured... Exiting" ; exit 1
    fi

    local XKB="/tmp/01-keyboard-layout.conf"
    local XK="$MNT/etc/X11/xorg.conf.d"
    local MLIST="/etc/pacman.d/mirrorlist"
    local BOOTIMG="/run/archiso/bootmnt/arch/boot/$ARCHI/vmlinuz"
    local AUTOSTART="$MNT/etc/skel/.config/openbox/autostart"
    local RFILES=("$BYPASS" "/archlabs-installer" "/etc/sudoers.d/g_wheel"
                  "/etc/mkinitcpio-archiso.conf" "/usr/bin/install-al"
                  "/etc/polkit-1/rules.d/49-nopasswd_global.rules")
    for f in "${RFILES[@]}"; do rm -rf ${MNT}"$f"; done
    find $MNT/usr/lib/initcpio -name archiso* -type f -exec rm '{}' \;

    sed -i '/al-hello/ c sleep 10; termite --exec=/usr/bin/al-hello &' $AUTOSTART
    sed -i 's|#$HOME/.config/setup &|$HOME/.config/setup &|g' $AUTOSTART
    sed -i 's/volatile/auto/g' $MNT/etc/systemd/journald.conf

    cp -f "$BOOTIMG" $MNT/boot/vmlinuz-linux 2>>"$ERR"
    cp -f  $MLIST ${MNT}$MLIST 2>>"$ERR"
    check_for_error

    [[ -e $XKB ]] && mkdir -p $XK ; cp -f $XKB $XK/01-keyboard.conf
    [[ -e /tmp/keyboard ]] && cp -f /tmp/keyboard $MNT/etc/default/keyboard
    [[ -e /tmp/vconsole.conf ]] && cp -f /tmp/vconsole.conf $MNT/etc/vconsole.conf

    arch_chroot "mkdir -p /var/lib/pacman/sync"
    arch_chroot "touch /var/lib/pacman/sync/{core.db,extra.db,community.db}"
    arch_chroot "dirmngr </dev/null"
    arch_chroot "gpg --receive-keys C1A60EACE707FDA5"
    arch_chroot "pacman-key --init && pacman-key --populate archlinux"
    local keys=('AEFB411B072836CD48FF0381AE252C284B5DBA5D'
                '9E4F11C6A072942A7B3FD3B0B81EB14A09A25EB0'
                '35F52A02854DCCAEC9DD5CC410443C7F54B00041')
    for i in "${keys[@]}"; do
        arch_chroot "gpg --receive-keys $i"
        arch_chroot "pacman-key -r $i"
        arch_chroot "pacman-key --lsign $i"
    done
    arch_chroot "pacman-key --populate archlabs"
    arch_chroot "pacman -Syy --noconfirm"
    arch_chroot "systemctl enable ntpd.service -f"
    arch_chroot "systemctl enable NetworkManager.service -f"
    arch_chroot "systemctl enable lightdm.service -f"
    arch_chroot "pacman -S iputils --noconfirm"
}


install_bootloader() {

    grub_configuration() {
        if [[ $LUKS_DEV != "" ]]; then
            sed -i "s~GRUB_CMDLINE_LINUX=.*~GRUB_CMDLINE_LINUX=\"${LUKS_DEV}\"~g" $MNT/etc/default/grub
        fi
        sed -i "s/GRUB_DISTRIBUTOR=.*/GRUB_DISTRIBUTOR=\"${DIST}\"/g" $MNT/etc/default/grub
        if [[ $SYSTEM == "BIOS" ]]; then
            if ([[ $LVM -eq 1 ]] && [[ $LVM_SEP_BOOT -eq 0 ]]) || [[ $LVM_SEP_BOOT -eq 2 ]]; then
                sed -i "s/GRUB_PRELOAD_MODULES=.*/GRUB_PRELOAD_MODULES=\"lvm\"/g" $MNT/etc/default/grub
            fi
        else
            local DIRS
            DIRS=($(find ${MNT}$EFI_MNT/EFI -maxdepth 1 -type d))
            for i in "${DIRS[@]}"; do
                d=$(basename "$i")
                if [[ $d == "BOOT" ]] || [[ $d == "Boot" ]] || [[ $d == "boot" ]]; then
                    BOOTDIR=$EFI_MNT/EFI/$d
                    break
                else
                    BOOTDIR=$EFI_MNT/EFI/boot
                fi
            done
            arch_chroot "mkdir -p $BOOTDIR"
            arch_chroot "cp -rf $EFI_MNT/EFI/$DIST/grubx64.efi $BOOTDIR/grubx64.efi"
            arch_chroot "cp -rf $EFI_MNT/EFI/$DIST/grubx64.efi $BOOTDIR/bootx64.efi"
        fi
        arch_chroot "grub-mkconfig -o /boot/grub/grub.cfg" 2>>"$ERR"
        check_for_error
    }

    bios_bootloader() {
        select_device
        dialog --backtitle "$BTITLE" --title " $_InstBootldr " --infobox "$_PlsWaitBody" 0 0
        arch_chroot "grub-install --target=i386-pc --recheck --force $DEVICE" 2>>"$ERR"
        check_for_error
        grub_configuration
    }

    uefi_bootloader() {
        if grep -q "/sys/firmware/efi/efivars" <<< "$(mount)"; then
            mount -t efivarfs efivarfs /sys/firmware/efi/efivars
        fi
        dialog --backtitle "$BTITLE" --title " $_InstBootldr " --infobox "$_PlsWaitBody" 0 0
        CMD="grub-install --target=x86_64-efi --efi-directory=$EFI_MNT --bootloader-id=$DIST --force"
        arch_chroot "$CMD" 2>>"$ERR"
        check_for_error
        grub_configuration
    }

    check_mount
    arch_chroot "export PATH=/usr/local/sbin:/usr/local/bin:/usr/bin:/bin:/usr/bin/core_perl"
    if [[ $SYSTEM == "BIOS" ]]; then
        bios_bootloader
    else
        uefi_bootloader
    fi
}


######################################################################
##                       Main Interfaces                            ##
######################################################################

security_menu() {
    if [[ $SUB_MENU != "security_menu" ]]; then
        SUB_MENU="security_menu" HIGHLIGHT=1
    else
        [[ $HIGHLIGHT != 4 ]] && HIGHLIGHT=$((HIGHLIGHT + 1))
    fi
    dialog --default-item $HIGHLIGHT --backtitle "$BTITLE" \
        --title " $_SecMenuTitle " --menu "$_SecMenuBody" 0 0 4 \
        "1" "$_SecJournTitle" \
        "2" "$_SecCoreTitle" \
        "3" "$_SecKernTitle" \
        "4" "$_Back" 2>$ANS
    HIGHLIGHT=$(cat $ANS)
    case "$(cat $ANS)" in
        "1")
            dialog --backtitle "$BTITLE" --title " $_SecJournTitle " --menu "$_SecJournBody" 0 0 7 \
                "$_Edit" "/etc/systemd/journald.conf" \
                "10M"  "SystemMaxUse=10M" \
                "20M"  "SystemMaxUse=20M" \
                "50M"  "SystemMaxUse=50M" \
                "100M" "SystemMaxUse=100M" \
                "200M" "SystemMaxUse=200M" \
                "$_Disable" "Storage=none" 2>$ANS
            if [[ $(cat $ANS) != "" ]]; then
                if  [[ $(cat $ANS) == "$_Disable" ]]; then
                    sed -i "s/#Storage.*\|Storage.*/Storage=none/g" $MNT/etc/systemd/journald.conf
                    sed -i "s/SystemMaxUse.*/#&/g" $MNT/etc/systemd/journald.conf
                    dialog --backtitle "$BTITLE" --title " $_SecJournTitle " --infobox "$_Done!" 0 0
                    sleep 2
                elif [[ $(cat $ANS) == "$_Edit" ]]; then
                    nano $MNT/etc/systemd/journald.conf
                else
                    sed -i "s/#Storage.*\|Storage.*/Storage=$(cat $ANS)/g" $MNT/etc/systemd/journald.conf
                    sed -i "s/SystemMaxUse.*/#&/g" $MNT/etc/systemd/journald.conf
                    dialog --backtitle "$BTITLE" --title " $_SecJournTitle " --infobox "$_Done!" 0 0
                    sleep 2
                fi
            fi ;;
        "2")
            dialog --backtitle "$BTITLE" --title " $_SecCoreTitle " --menu "$_SecCoreBody" 0 0 2 \
                "$_Disable" "Storage=none" \
                "$_Edit"    "/etc/systemd/coredump.conf" 2>$ANS
            if [[ $(cat $ANS) == "$_Disable" ]]; then
                sed -i "s/#Storage.*\|Storage.*/Storage=none/g" $MNT/etc/systemd/coredump.conf
                dialog --backtitle "$BTITLE" --title " $_SecCoreTitle " --infobox "$_Done!" 0 0
                sleep 2
            elif [[ $(cat $ANS) == "$_Edit" ]]; then
                nano $MNT/etc/systemd/coredump.conf
            fi ;;
        "3")
            dialog --backtitle "$BTITLE" --title " $_SecKernTitle " --menu "$_SecKernLogs" 0 0 2 \
                "$_Disable" "kernel.dmesg_restrict = 1" \
                "$_Edit"    "/etc/systemd/coredump.conf.d/custom.conf" 2>$ANS
            case "$(cat $ANS)" in
                "$_Disable")
                    echo "kernel.dmesg_restrict = 1" >$MNT/etc/sysctl.d/50-dmesg-restrict.conf
                    dialog --backtitle "$BTITLE" --title " $_SecKernTitle " --infobox "$_Done!" 0 0
                    sleep 2 ;;
                "$_Edit")
                    if [[ -e $MNT/etc/sysctl.d/50-dmesg-restrict.conf ]]; then
                        nano $MNT/etc/sysctl.d/50-dmesg-restrict.conf
                    else
                        MSG="$_SeeConfErrBody $MNT/etc/sysctl.d/50-dmesg-restrict.conf"
                        dialog --backtitle "$BTITLE" --title " Config Missing " --msgbox "$MSG" 0 0
                    fi
            esac ;;
        *) main_menu
    esac
    security_menu
}

greeting() {
    dialog --backtitle "$BTITLE" --title " $_WelTitle $VERSION " --msgbox "$_WelBody" 0 0
}

prep_menu() {
    if [[ $SUB_MENU != "prep_menu" ]]; then
        SUB_MENU="prep_menu" HIGHLIGHT=1
    else
        [[ $HIGHLIGHT != 8 ]] && HIGHLIGHT=$((HIGHLIGHT + 1))
    fi
    dialog --default-item $HIGHLIGHT --backtitle "$BTITLE" \
        --title " $_PrepMenuTitle " --menu "$_PrepMenuBody" 0 0 8 \
        "1" "$_VCKeymapTitle" \
        "2" "$_PrepKBLayout" \
        "3" "$_DevShowOpt" \
        "4" "$_PrepPartDisk" \
        "5" "$_PrepLUKS" \
        "6" "$_PrepLVM" \
        "7" "$_PrepMntPart" \
        "8" "$_Back" 2>$ANS
    HIGHLIGHT=$(cat $ANS)
    case "$(cat $ANS)" in
        "1") set_keymap       ;;
        "2") set_xkbmap       ;;
        "3") show_devices     ;;
        "4") umount_partitions ; select_device ; create_partitions ;;
        "5") luks_menu        ;;
        "6") lvm_menu         ;;
        "7") mount_partitions ;;
        *)   main_menu
    esac
    prep_menu
}

install_root_menu() {
    if [[ $SUB_MENU != "install_base_menu" ]]; then
        SUB_MENU="install_base_menu" HIGHLIGHT=1
    else
        [[ $HIGHLIGHT != 5 ]] && HIGHLIGHT=$((HIGHLIGHT + 1))
    fi
    dialog --default-item $HIGHLIGHT --backtitle "$BTITLE" --title "$_InstBseMenuTitle" \
        --menu "$_InstBseMenuBody" 0 0 5 \
        "1" "$_InstBse" \
        "2" "$_MMRunMkinit" \
        "3" "$_ConfBseFstab" \
        "4" "$_InstBootldr" \
        "5" "$_Back" 2>$ANS
    HIGHLIGHT=$(cat $ANS)
    case "$(cat $ANS)" in
        "1") install_root       ;;
        "2") run_mkinitcpio     ;;
        "3") generate_fstab     ;;
        "4") install_bootloader ;;
        *)   main_menu
    esac
    install_root_menu
}

config_base_menu() {
    arch_chroot "PATH=/usr/local/sbin:/usr/local/bin:/usr/bin:/usr/bin/core_perl" 2>>"$ERR"
    check_for_error
    if [[ $SUB_MENU != "config_base_menu" ]]; then
        SUB_MENU="config_base_menu" HIGHLIGHT=1
    else
        [[ $HIGHLIGHT != 7 ]] && HIGHLIGHT=$((HIGHLIGHT + 1))
    fi
    dialog --default-item $HIGHLIGHT --backtitle "$BTITLE" --title " $_ConfBseMenuTitle " \
        --menu "$_ConfBseBody" 0 0 7 \
        "1" "$_ConfBseHost" \
        "2" "$_ConfBseSysLoc" \
        "3" "$_ConfBseTimeHC"\
        "4" "$_ConfUsrRoot" \
        "5" "$_ConfUsrNew" \
        "6" "$_SecMenuTitle" \
        "7" "$_Back" 2>$ANS
    HIGHLIGHT=$(cat $ANS)
    case "$(cat $ANS)" in
        "1") set_hostname      ;;
        "2") set_locale        ;;
        "3") set_timezone ; set_hw_clock ;;
        "4") set_root_password ;;
        "5") create_new_user   ;;
        "6") security_menu     ;;
        *)   main_menu
    esac
    config_base_menu
}

edit_configs() {
    FILE=""
    if [[ $SUB_MENU != "edit configs" ]]; then
        SUB_MENU="edit configs" HIGHLIGHT=1
    else
        [[ $HIGHLIGHT != 12 ]] && HIGHLIGHT=$((HIGHLIGHT + 1))
    fi
    dialog --default-item $HIGHLIGHT --backtitle "$BTITLE" --title " $_SeeConfOptTitle " \
        --menu "$_SeeConfOptBody" 0 0 12 \
        "1" "/etc/vconsole.conf" \
        "2" "/etc/locale.conf" \
        "3" "/etc/hostname" \
        "4" "/etc/hosts" \
        "5" "/etc/sudoers" \
        "6" "/etc/mkinitcpio.conf" \
        "7" "/etc/fstab" \
        "8" "/etc/crypttab" \
        "9" "/etc/default/grub" \
        "10" "/etc/lightdm" \
        "11" "/etc/pacman.conf" \
        "12" "$_Back" 2>$ANS
    HIGHLIGHT=$(cat $ANS)
    case "$(cat $ANS)" in
        "1") [[ -e $MNT/etc/vconsole.conf   ]] && FILE="$MNT/etc/vconsole.conf"   ;;
        "2") [[ -e $MNT/etc/locale.conf     ]] && FILE="$MNT/etc/locale.conf"     ;;
        "3") [[ -e $MNT/etc/hostname        ]] && FILE="$MNT/etc/hostname"        ;;
        "4") [[ -e $MNT/etc/hosts           ]] && FILE="$MNT/etc/hosts"           ;;
        "5") [[ -e $MNT/etc/sudoers         ]] && FILE="$MNT/etc/sudoers"         ;;
        "6") [[ -e $MNT/etc/mkinitcpio.conf ]] && FILE="$MNT/etc/mkinitcpio.conf" ;;
        "7") [[ -e $MNT/etc/fstab           ]] && FILE="$MNT/etc/fstab"           ;;
        "8") [[ -e $MNT/etc/crypttab        ]] && FILE="$MNT/etc/crypttab"        ;;
        "9") [[ -e $MNT/etc/default/grub    ]] && FILE="$MNT/etc/default/grub"    ;;
        "10")
            if [[ -e $MNT/etc/lightdm/lightdm.conf ]]; then
                FILE="$MNT/etc/lightdm/lightdm.conf"
                for f in $(find $MNT/etc/lightdm | awk -F"/" '{print $NF}'); do
                    [[ $f == *greeter.conf ]] && FILE="$FILE $MNT/etc/lightdm/$f"
                done
            fi ;;
        "11") [[ -e $MNT/etc/pacman.conf ]] && FILE="$MNT/etc/pacman.conf" ;;
        *) main_menu
    esac
    if [[ $FILE != "" ]] && [[ $DISPLAY ]] && hash geany &>/dev/null; then
        geany -i $FILE
    elif [[ $FILE != "" ]]; then
        nano -p $FILE
    else
        dialog --backtitle "$BTITLE" --title " $_ErrTitle " --msgbox "$_SeeConfErrBody" 0 0
    fi
    edit_configs
}


main_menu() {
    if [[ $MHIGHLIGHT != 5 ]]; then
        if ! [[ -e $MNT/etc ]] && [[ $MHIGHLIGHT != 1 ]]; then
            MHIGHLIGHT=1
        else
            MHIGHLIGHT=$((MHIGHLIGHT + 1))
        fi
    fi
    dialog --default-item $MHIGHLIGHT --backtitle "$BTITLE" --title " $_MMTitle " \
        --menu "$_MMBody" 0 0 5 \
        "1" "$_PrepMenuTitle" \
        "2" "$_InstBseMenuTitle" \
        "3" "$_ConfBseMenuTitle" \
        "4" "$_SeeConfOptTitle" \
        "5" "$_Done" 2>$ANS
    MHIGHLIGHT=$(cat $ANS)
    if [[ $(cat $ANS) -eq 2 ]]; then
        check_mount
    elif [[ $(cat $ANS) -ge 3 ]] && [[ $(cat $ANS) -le 4 ]]; then
        check_mount
        check_base
    fi
    case "$(cat $ANS)" in
        "1") prep_menu         ;;
        "2") install_root_menu ;;
        "3") config_base_menu  ;;
        "4") edit_configs      ;;
        *)
            if dialog --backtitle "$BTITLE" --yesno "$_CloseInstBody" 8 45; then
                umount_partitions
                clear && exit 0
            else
                main_menu
            fi
    esac
    main_menu
}

id_system
select_language
check_requirements
greeting

while true; do
    main_menu
done
