#!/usr/bin/env bash
# vim:ft=sh:fdm=marker:fmr={,}

# Modified by Nathaniel Maia for use in Archlabs
# Originally Written by Carl Duff for PacBang Linux
# This program is free software, provided under the GNU GPL

ISO_USER="liveuser"                   # Live user account
DIST="Archlabs"                       # Distributor name for grub etc
VER="$DIST Installer 1.3.2"           # Installer Name / Version
ANS="/tmp/.archlabs-installer"        # Temp file to store answers
MNT_OPTS="/tmp/.mnt_opts"             # file system mount options
MNT="/mnt"                            # Installation mountpoint
ERR="/tmp/.errlog"                    # error log file
EFI_MNT="boot/efi"                    # EFI partition mountpoint
VG_MB=0                               # MB remaining of VG
LVM_SEP_BOOT=0                        # 1 = Seperate /boot, 2 = seperate /boot & LVM
SYS_IMG="/run/archiso/sfs/airootfs/"  # Squash image to install
KERN_IMG="/run/archiso/bootmnt/arch/boot/x86_64/vmlinuz"

######################################################################
##                  Utility and Check Functions                     ##
######################################################################

select_lang() {
    dlg " Select Language " --menu \
        "Language - sprache - taal - språk - lingua - idioma - nyelv - língua" 0 0 9 \
        "1" "English            (en_**)" "2" "Español            (es_ES)" \
        "3" "Português [Brasil] (pt_BR)" "4" "Português          (pt_PT)" \
        "5" "Français           (fr_FR)" "6" "Russkiy            (ru_RU)" \
        "7" "Italiano           (it_IT)" "8" "Nederlands         (nl_NL)" \
        "9" "Magyar             (hu_HU)" 2> $ANS
    case "$(cat $ANS)" in
        1) . /archlabs-installer/english.trans ; LOC="en_US.UTF-8" ;;
        2) . /archlabs-installer/spanish.trans ; LOC="es_ES.UTF-8" ;;
        3) . /archlabs-installer/p_brasil.trans ; LOC="pt_BR.UTF-8" ;;
        4) . /archlabs-installer/portuguese.trans ; LOC="pt_PT.UTF-8" ;;
        5) . /archlabs-installer/french.trans ; LOC="fr_FR.UTF-8" ;;
        6) . /archlabs-installer/russian.trans ; LOC="ru_RU.UTF-8" ;;
        7) . /archlabs-installer/italian.trans ; LOC="it_IT.UTF-8" ;;
        8) . /archlabs-installer/dutch.trans ; LOC="nl_NL.UTF-8" ;;
        9) . /archlabs-installer/hungarian.trans ; LOC="hu_HU.UTF-8" ;;
        *) exit 0
    esac
    sed -i "s/#en_US.UTF-8/en_US.UTF-8/" /etc/locale.gen
    [[ $LOC != "en_US.UTF-8" ]] && sed -i "s/#${LOC}/${LOC}/" /etc/locale.gen
    locale-gen >/dev/null 2>&1
    export LANG="$LOC"
}

check_req() {
    if [[ $(whoami) != "root" || ! $(ping -c 1 google.com) ]]; then
        [[ $(whoami) != "root" ]] && msg="$_RtFailBody" || msg="$_ConFailBody"
        dlg " $_ErrTitle " --infobox "$msg" 0 0
        sleep 3 && exit 1
    fi
    echo "" > $ERR
    if [[ $DBG ]]; then
        # sudo -s
        # exec 3>| /tmp/log.txt
        # BASH_XTRACEFD=3
        # bash -x /archlabs-installer/archlabs-installer
        echo "" > /tmp/log.txt
        exec 3>| /tmp/log.txt
        BASH_XTRACEFD=3
        set -x
        ( termite -e "tail -f /tmp/log.txt" & )
    fi
}

id_system() {
    if grep -q 'Apple' /sys/class/dmi/id/sys_vendor; then
        modprobe -r -q efivars || true
    else
        modprobe -q efivarfs
    fi
    if [[ -d "/sys/firmware/efi/" ]]; then
        if grep -q /sys/firmware/efi/efivars <<< "$(mount)"; then
            mount -t efivarfs efivarfs /sys/firmware/efi/efivars
        fi
        SYSTEM="UEFI"
    else
        SYSTEM="BIOS"
    fi
    BT=("--backtitle" "$VER - $SYSTEM (x86_64)")
}

check_errors() {
    if [[ $? -eq 1 ]] && grep -wqi "error" "$ERR"; then
        local msg
        msg=$(cat "$ERR")
        dlg " $_ErrTitle " --msgbox "$msg" 0 0
        msg="An error was encountered during install
        \n\n'Yes' to keep install intact and fix manually
        \n'No' to wipe install (preserves /boot)"
        if ! dlg " $_ErrTitle " --yesno "$msg" 9 55; then
            for d in $MNT/?*; do
                if ! grep "boot" <<< "$f"; then
                    rm -rf $d || continue
                fi
            done
        fi
        echo "" > $ERR # wipe error log
        main_menu
    fi
    return 0
}

check_mount() {
    if ! grep -q "$MNT" <<< "$(lsblk -o MOUNTPOINT)"; then
        dlg " $_ErrTitle " --msgbox "$_ErrNoMount" 0 0
        return 1
    fi
    return 0
}

check_base() {
    if ! [[ -e $MNT/etc ]]; then
        dlg " $_ErrTitle " --msgbox "$_ErrNoBase" 0 0
        return 1
    fi
    return 0
}

show_devices() {
    lsblk -o NAME,MODEL,TYPE,FSTYPE,SIZE,MOUNTPOINT |
        grep "disk\|part\|lvm\|crypt\|NAME\|TYPE\|SIZE" >/tmp/.devlist
    dlg " $_DevShowOpt " --textbox /tmp/.devlist 0 0
}

chr() {
    arch-chroot $MNT /bin/bash -c "$1"
}

log() {
    echo "$1" >> /tmp/log.txt
}

dlg() {
    dialog ${BT[@]} --column-separator "|" --exit-label "$_Back" "$@"
}

######################################################################
##                  System Settings Functions                       ##
######################################################################

set_keymap() {
    set_xorg_keymap() {
        local msg ttl map maps kmaps dk k
        maps=""
        kmaps=('af' 'al' 'am' 'at' 'az' 'ba' 'bd' 'be' 'bg' 'br' 'bt' 'bw'
        'by' 'ca' 'cd' 'ch' 'cm' 'cn' 'cz' 'de' 'dk' 'ee' 'es' 'et' 'eu'
        'fi' 'fo' 'fr' 'gb' 'ge' 'gh' 'gn' 'gr' 'hr' 'hu' 'ie' 'il' 'in'
        'iq' 'ir' 'is' 'it' 'jp' 'ke' 'kg' 'kh' 'kr' 'kz' 'la' 'lk' 'lt'
        'lv' 'ma' 'md' 'me' 'mk' 'ml' 'mm' 'mn' 'mt' 'mv' 'ng' 'nl' 'no'
        'np' 'pc' 'ph' 'pk' 'pl' 'pt' 'ro' 'rs' 'ru' 'se' 'si' 'sk' 'sn'
        'sy' 'tg' 'th' 'tj' 'tm' 'tr' 'tw' 'tz' 'ua' 'us' 'uz' 'vn' 'za'
        )
        for i in "${kmaps[@]}"; do maps="$maps $i -"; done
        msg="$_XkbmapBody"
        ttl=" $_PrepKBLayout "
        dlg "$ttl" --menu "$msg" 22 60 16 $maps 2> $ANS || prep_menu
        map=$(sed 's/_.*//' $ANS)
        setxkbmap "$map" 2> $ERR
        check_errors
        k='Section "InputClass"\n\tIdentifier "system-keyboard"\n\tMatchIsKeyboard "on"'
        k="$k\n\tOption \"XkbLayout\" \"$map\"\nEndSection"
        dk='# KEYBOARD CONFIGURATION FILE\n\nConsult the keyboard(5) manual page.'
        dk="$dk\n\nXKBMODEL=\"\"\nXKBLAYOUT=\"$map\"\nXKBVARIANT=\"\""
        dk="$dk\nXKBOPTIONS=\"\"\nBACKSPACE=\"guess\""
        echo -e "$k" >/tmp/01-keyboard.conf
        echo -e "$dk" >/tmp/keyboard
        log "Setting xorg keymap to $map"
    }

    set_console_keymap() {
        local msg ttl cmaps maps
        maps=""
        cmaps=$(ls -R /usr/share/kbd/keymaps | grep "map.gz")
        cmaps=$(sed 's/\.map\.gz//g' <<< "$cmaps" | sort)
        for i in $cmaps; do maps="$maps $i -"; done
        msg="$_VCKeymapBody"
        ttl=" $_VCKeymapTitle "
        dlg "$ttl" --menu "$msg" 22 60 16 $maps 2> $ANS || prep_menu
        echo "KEYMAP=$(cat $ANS)" > /tmp/vconsole.conf
        log "Setting vconsole keymap to $(cat $ANS)"
    }
    set_console_keymap
    set_xorg_keymap
}

set_locale() {
    local ttl=" $_ConfBseSysLoc "
    local msg="$_localeBody"
    local loc=""
    local lc=$(sed 's/ UTF-8//g' <<< "$(sed 's/#//g' <<< "$(grep -v "# " /etc/locale.gen)")")
    for i in $(grep .UTF-8 <<< "$lc"); do loc="$loc $i -"; done
    dlg "$ttl" --menu "$msg" 20 60 12 $loc 2> $ANS || config_menu
    loc=$(cat $ANS)
    sed -i "s/en_US.UTF-8/${loc}/g" $MNT/etc/locale.conf
    cp -f $MNT/etc/locale.conf $MNT/etc/default/locale
    sed -i "s/#en_US.UTF-8/en_US.UTF-8/g" $MNT/etc/locale.gen
    sed -i "s/#${loc}/${loc}/g" $MNT/etc/locale.gen
    sed -i "s/en_US.UTF-8/${loc}/g" $MNT/etc/default/locale
    chr "locale-gen" >/dev/null 2>>"$ERR"
    log "Setting locale to $loc"
    check_errors
    set_timezone
}

set_timezone() {
    local zone="" sub="" ttl="" msg=""
    full=$(awk '{print $3}' < /usr/share/zoneinfo/zone.tab | grep ".*/.*" | sort -ud)
    if [[ $manual != "True" ]]; then
        geo=$(curl --silent freegeoip.net/xml/) geo=${geo#*<TimeZone>} geo=${geo%</TimeZone>*}
        [[ $full =~ "$geo" ]] && { zone=${geo%/*} sub=${geo#*/} ;}
    else
        for i in $(awk -F/ '{print $1}' <<< "$full"); do zone="$zone $i -"; done
        ttl=" $_ConfBseTimeHC "
        msg="$_TimeZBody"
        dlg "$ttl" --menu "$msg" 20 45 10 $zone 2>$ANS || config_menu
        zone=$(cat $ANS)
        for i in $(awk -F"$zone/" '{print $2}' <<< "$full" | sort -ud); do sub="$sub $i -";done
        msg="$_TimeSubZBody"
        dlg "$ttl" --menu "$msg" 20 45 11 $SUB 2>$ANS || config_menu
        SUB=$(cat $ANS)
    fi
    if [[ $zone && $sub ]]; then
        ttl=" $_ConfBseTimeHC "
        msg="$_TimeZQ $zone/$sub?\n\n"
        if dlg "$ttl" --yesno "$msg" 0 0; then
            log "Setting timezone to $zone/$sub"
            chr "ln -sf /usr/share/zoneinfo/$zone/$sub /etc/localtime" 2> $ERR
            check_errors
        else
            MANUAL="True"
            set_timezone
        fi
    else
        MANUAL="True"
        set_timezone
    fi
    SET="True"
    set_hw_clock
}

set_hw_clock() {
    log "Setting hwclock"
    chr "hwclock --systohc --utc"
    if (( $? == 1 )); then
        chr "hwclock --systohc --utc --directisa" 2>>"$ERR"
        if (( $? == 1 )) && grep -wqi "error" "$ERR"; then
            dlg " $_ErrTitle " --msgbox "$(cat "$ERR")" 0 0
            echo "" > $ERR
        fi
    fi
}

set_hostname() {
    host=${DIST,,}
    dlg "$_ConfBseHost" --inputbox "$_HostNameBody" 14 60 "$host" 2>$ANS || config_menu
    host=$(cat $ANS)
    log "Setting hostname as: $host"
    echo "$host" > $MNT/etc/hostname
    echo "127.0.0.1    localhost
127.0.1.1    $host
::1     localhost ip6-localhost ip6-loopback
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters" > $MNT/etc/hosts
}

root_password() {
    local ttl=" $_ConfUsrRoot "
    dlg "$ttl" --clear --insecure --passwordbox "$_PassRtBody" 8 40 2>$ANS || config_menu
    PASSWD=$(cat $ANS)
    dlg "$ttl" --clear --insecure --passwordbox "$_PassRtBody2" 8 40 2>$ANS || config_menu
    PASSWD2=$(cat $ANS)
    PASS=""
    if [[ $PASSWD == "$PASSWD2" ]]; then
        echo -e "$PASSWD\n$PASSWD" >/tmp/.passwd
        chr "passwd root" </tmp/.passwd >/dev/null 2>>"$ERR"
        rm /tmp/.passwd
        check_errors
        PASS="True"
    else
        dlg " $_ErrTitle " --msgbox "$_PassErrBody" 0 0
        root_password
    fi
}

create_user() {
    dlg " $_NUsrTitle " --inputbox "$_NUsrBody" 10 40 "" 2>$ANS || config_menu
    usr=$(cat $ANS)
    while [[ ${#usr} -eq 0 || $usr =~ \ |\' || $usr =~ [^a-z0-9\ ] ]]; do
        dlg " $_NUsrTitle " --inputbox "$_NUsrErrBody" 10 40 "" 2>$ANS || config_menu
        usr=$(cat $ANS)
    done
    local msg1="$_PassNUsrBody $usr"
    local ttl=" $_ConfUsrNew "
    dlg "$ttl" --clear --insecure --passwordbox "$msg1" 8 40 2>$ANS || config_menu
    PASSWD=$(cat $ANS)
    local msg2="$_PassNUsrBody2 $usr"
    dlg "$ttl" --clear --insecure --passwordbox "$msg2" 8 40 2>$ANS || config_menu
    PASSWD2=$(cat $ANS)
    while [[ $PASSWD != "$PASSWD2" ]]; do
        dlg " $_ErrTitle " --msgbox "$_PassErrBody" 8 60
        dlg "$ttl" --clear --insecure --passwordbox "$msg1" 8 40 2>$ANS || config_menu
        PASSWD=$(cat $ANS)
        dlg "$ttl" --clear --insecure --passwordbox "$msg2" 8 40 2>$ANS || config_menu
        PASSWD2=$(cat $ANS)
    done
    dlg "$ttl" --infobox "$_NUsrSetBody" 0 0
    sleep 2 && echo -e "$PASSWD\n$PASSWD" >/tmp/.passwd
    group="rfkill,wheel,autologin,network,lp,storage,power,video,audio,lp"
    # If the first user account, change the live account
    if [[ -e $MNT/home/$ISO_USER ]]; then
        chr "passwd $ISO_USER" </tmp/.passwd >/dev/null 2> $ERR
        check_errors
        log "Creating user: $usr and setting groups: $group"
        WHEEL="%wheel ALL=(ALL) ALL"
        OPENBOX="$MNT/home/$ISO_USER/.config/openbox"
        L_FILES=(/etc/systemd/system/autologin@.service
        "/home/$ISO_USER/.config/openbox/autostart"
        /etc/group /etc/gshadow /etc/passwd /etc/shadow)
        for f in "${L_FILES[@]}"; do sed -i "s/${ISO_USER}/${usr}/g" ${MNT}"$f"; done
        if grep -q "welcome.sh" $OPENBOX/autostart; then
            sed -i '/welcome.sh/d' $OPENBOX/autostart
        fi
        if grep -q 'item label="W e l c o m e"' $OPENBOX/menu.xml; then
            sed -i '/item label="W e l c o m e"/ i\    <separator label="A r c h L a b s"/>' $OPENBOX/menu.xml
            sed -i '/item label="W e l c o m e"/ { N; N; N; N; N; N; N; N; N; N; N; d; }' $OPENBOX/menu.xml
        fi
        if grep -q "archlabs-installer" $OPENBOX/rc.xml; then
            sed -i '/archlabs-installer/ { N; N; d; }' $OPENBOX/rc.xml
        fi
        sed -i 's/#$HOME/$HOME/g' $OPENBOX/autostart
        sed -i '/keypack/d' $OPENBOX/autostart
        sed -i '/al-hello/ c sleep 10; termite -e al-hello &' $OPENBOX/autostart
        rm -f $MNT/home/$ISO_USER/.config/keypack
        rm -f $MNT/home/$ISO_USER/bin/welcome.sh
        log "Swapping $ISO_USER /home/ to $usr"
        chr "mv /home/$ISO_USER /home/$usr" 2>$ERR
        chr "chown -R $usr:users /home/$usr" 2>>$ERR
        chr "usermod -aG $group $usr" 2>>$ERR
        sed -i "s/# ${WHEEL}/${WHEEL}/g" $MNT/etc/sudoers
        check_errors
    else
        log "Creating new /home/ for $usr"
        chr "useradd $usr -m -g users -G $group -s /bin/zsh" 2>$ERR
        chr "passwd $usr" < /tmp/.passwd >/dev/null 2>>$ERR
        chr "cp -R /etc/skel/ /home/$usr" 2>>$ERR
        chr "chown -R ${usr}:users /home/$usr" 2>>$ERR
        check_errors
    fi
    rm /tmp/.passwd
    if [[ -d $MNT/etc && $SET == "True" && $PASS == "True" && $BOOTD == "True" ]]; then
        ttl="Installation Finished"
        msg="The install is now complete
        \n\n'Yes' to close the installer and reboot
        \n\n'No' to modify system config files"
        if dlg " $ttl " --yesno "$msg" 10 60; then
            umount_parts ; clear ; reboot
        else
            edit_configs
        fi
    fi
}

######################################################################
##                System and Partitioning Functions                 ##
######################################################################

umount_parts() {
    MOUNTED=$(mount | grep "$MNT" | awk '{print $3}' | sort -r)
    swapoff -a
    for i in $MOUNTED; do
        umount -r "$i" >/dev/null 2>>"$ERR"
    done
    check_errors
}

confirm_mount() {
    local ttl msg
    ttl=" $_MntStatusTitle "
    if grep -q "$1" <<< "$(mount)"; then
        dlg "$ttl" --infobox "$_MntStatusSucc" 0 0 && sleep 2
        PARTS=$(sed "s~${PART} [0-9]*[G-M]~~" <<< "$PARTS")
        PARTS=$(sed "s~${PART} [0-9]*\.[0-9]*[G-M]~~" <<< "$PARTS" | sed s~${PART}$' -'~~)
        ((NUM_PARTS--))
    else
        dlg "$ttl" --infobox "$_MntStatusFail" 0 0 && sleep 2
        prep_menu
    fi
}

select_device() {
    local msg
    DEVICE=""
    [[ $1 == "grub" ]] && msg="$_DevSelTitle for Bootloader\n\n$_DevSelBody" || msg="$_DevSelBody"
    DEVS=$(lsblk -lno NAME,SIZE,TYPE | grep 'disk' | awk '{print "/dev/" $1 " " $2}' | sort -u)
    dlg " $_DevSelTitle " --menu "$msg" 0 0 4 $DEVS 2>$ANS || prep_menu
    DEVICE=$(cat $ANS)
}

find_parts() {
    PARTS=""
    NUM_PARTS=0
    LBLK=$(lsblk -lno NAME,SIZE,TYPE | grep "$INC_PART" | sed 's/part$/\/dev\//g')
    LBLK=$(sed 's/lvm$\|crypt$/\/dev\/mapper\//g' <<< "$LBLK")
    PARTS=$(awk '{print $3$1 " " $2}' <<< "$LBLK" | sort -u)
    for i in $PARTS; do ((NUM_PARTS++)); done
    NUM_PARTS=$((NUM_PARTS / 2))
    case $INC_PART in
        'part\|lvm\|crypt')
            if [[ $SYSTEM == "UEFI" && $NUM_PARTS -lt 2 ]]; then
                dlg " $_ErrTitle " --msgbox "$_PartErrBody" 0 0
                create_parts
            elif [[ $SYSTEM == "BIOS" && $NUM_PARTS -eq 0 ]]; then
                dlg " $_ErrTitle " --msgbox "$_PartErrBody" 0 0
                create_parts
            fi ;;
        'part\|crypt')
            if (( $NUM_PARTS == 0 )); then
                dlg " $_ErrTitle " --msgbox "$_LvmPartErrBody" 0 0
                create_parts
            fi ;;
        'part\|lvm')
            if (( $NUM_PARTS < 2 )); then
                dlg " $_ErrTitle " --msgbox "$_LuksPartErrBody" 0 0
                create_parts
            fi
    esac
}

create_parts() {
    secure_wipe() {
        local msg="$_AutoPartBody1 $DEVICE $_AutoPartBody2 $_AutoPartBody3"
        if dlg " $_PartOptWipe " --yesno "$msg" 0 0; then
            clear ; echo -e "Secure wiping $DEVICE this will take a while.."
            wipe -Ifre "$DEVICE"
        else
            create_parts
        fi
    }

    auto_partition() {
        if [[ $SYSTEM == "BIOS" ]]; then
            _AutoPartBody2="will be destroyed.\n\nAn ext4 partition will be created using all available space."
        fi
        local msg="$_AutoPartBody1 $DEVICE $_AutoPartBody2 $_AutoPartBody3"
        if dlg " $_PrepPartDisk " --yesno "$msg" 0 0; then
            dp=$(parted -s "$DEVICE" print | awk '/^ / {print $1}' | sort -r)
            for p in $dp; do
                parted -s "$DEVICE" rm $p 2>$ERR
                check_errors
            done
            table=$(parted -s "$DEVICE" print | grep -i 'partition table' | awk '{print $3}')
            if [[ $SYSTEM == "BIOS" && $table != "msdos" ]]; then
                parted -s "$DEVICE" mklabel msdos 2>$ERR
            elif [[ $SYSTEM == "UEFI" && $table != "gpt" ]]; then
                parted -s "$DEVICE" mklabel gpt 2>$ERR
            fi
            check_errors
            if [[ $SYSTEM == "BIOS" ]]; then
                parted -s "$DEVICE" mkpart primary ext4 1MiB 100% 2>$ERR
            else
                parted -s "$DEVICE" mkpart ESP fat32 1MiB 513MiB 2>$ERR
                parted -s "$DEVICE" set 1 boot on 2>>$ERR
                parted -s "$DEVICE" mkpart primary ext4 513MiB 100% 2>>$ERR
            fi
            check_errors
            lsblk "$DEVICE" -o NAME,TYPE,FSTYPE,SIZE >/tmp/.devlist
            dlg "" --textbox /tmp/.devlist 0 0
        else
            create_parts
        fi
    }
    dlg "$_PartToolTitle" --menu "$_PartToolBody" 0 0 5 \
        "$_PartOptWipe" "BIOS & UEFI" \
        "$_PartOptAuto" "BIOS & UEFI" \
        "gparted"       "BIOS & UEFI" \
        "cfdisk"        "BIOS/MBR" \
        "parted"        "UEFI/GPT" 2> $ANS
    RET=$(cat $ANS)
    if [[ $RET ]]; then
        if [[ $RET != "$_PartOptWipe" && $RET != "$_PartOptAuto" ]]; then
            $RET "$DEVICE"
        elif [[ $RET == "$_PartOptWipe" ]]; then
            secure_wipe && create_parts
        else
            auto_partition
        fi
    fi
}

choose_fs() {
    FS_OPTS=()
    dlg " $_FSTitle " --menu "$_FSBody" 0 0 12 \
        "$_Skip"   "-" \
        "ext4"     "mkfs.ext4 -q" \
        "ext3"     "mkfs.ext3 -q" \
        "ext2"     "mkfs.ext2 -q" \
        "btrfs"    "mkfs.btrfs -f" \
        "f2fs"     "mkfs.f2fs" \
        "jfs"      "mkfs.jfs -q" \
        "nilfs2"   "mkfs.nilfs2 -q" \
        "ntfs"     "mkfs.ntfs -q" \
        "reiserfs" "mkfs.reiserfs -q" \
        "vfat"     "mkfs.vfat -F32" \
        "xfs"      "mkfs.xfs -f" 2> $ANS
    select=$(cat $ANS)
        case $select in
            "$_Skip") FS="$_Skip" ;;
            ext4) FS="mkfs.ext4 -q" FS_OPTS=(dealloc discard noacl noatime nobarrier nodelalloc) ;;
            ext3) FS="mkfs.ext3 -q" ;;
            ext2) FS="mkfs.ext2 -q" ;;
            btrfs) FS="mkfs.btrfs -f"
                FS_OPTS=(autodefrag "compress=zlib" "compress=lzo"
                "compress=no" "compress-force=zlib" "compress-force=lzo"
                discard noacl noatime nodatasum nospace_cache recovery
                skip_balance space_cache ssd ssd_spread)
                modprobe btrfs
                ;;
            f2fs) FS="mkfs.f2fs"
                FS_OPTS=(data_flush disable_roll_forward disable_ext_identify
                discard fastboot flush_merge inline_xattr inline_data inline_dentry
                no_heap noacl nobarrier noextent_cache noinline_data norecovery)
                modprobe f2fs
                ;;
            jfs) FS="mkfs.jfs -q" FS_OPTS=(discard "errors=continue" "errors=panic" nointegrity) ;;
            nilfs2) FS="mkfs.nilfs2 -q" FS_OPTS=(discard nobarrier "errors=continue" "errors=panic" "order=relaxed" "order=strict" norecovery) ;;
            ntfs) FS="mkfs.ntfs -q" ;;
            reiserfs) FS="mkfs.reiserfs -q" FS_OPTS=(acl nolog notail replayonly user_xattr) ;;
            vfat) FS="mkfs.vfat -F32" ;;
            xfs) FS="mkfs.xfs -f" FS_OPTS=(discard filestreams ikeep largeio noalign nobarrier norecovery noquota wsync) ;;
            *) prep_menu
        esac
        if [[ $FS != "$_Skip" ]]; then
            local msg=""
            if dlg " $_FSTitle " --yesno "\nFormat $PART as $select?\n\n" 0 0; then
                log "Formatting $PART as $FS"
                msg="\nFormatting $PART as $select.\n$_PlsWaitBody"
                dlg " $_FSTitle " --infobox "$msg" 8 45
                $FS $PART >/dev/null 2> $ERR
                check_errors
            else
                choose_fs
            fi
        fi
    }

mount_parts() {
    opts() {
        local ttl msg
        OPTS=""
        for i in "${FS_OPTS[@]}"; do OPTS="$OPTS $i - off"; done
        echo "" >$MNT_OPTS
        ttl=" $(sed "s/.*\.//g" <<< "$FS" | sed "s/-.*//g") "
        dlg "$ttl" --checklist "$_MntBody" 0 0 ${#FS_OPTS[@]} $OPTS 2>$MNT_OPTS
        sed -i 's/ /,/g' $MNT_OPTS
        sed -i '$s/,$//' $MNT_OPTS
        if [[ $(cat $MNT_OPTS) != "" ]]; then
            msg="${_MntConfBody}$(cat $MNT_OPTS)\n"
            ttl=" $_MntStatusTitle "
            if ! dlg "$ttl" --yesno "$msg" 10 75; then
                opts
            fi
        fi
    }

    mnt_chosen() {
        mkdir -p "${MNT}$MOUNT" 2>>"$ERR"
        [[ ${#FS_OPTS[@]} -gt 0 ]] && opts || sleep 0.1
        if [[ $(cat $MNT_OPTS) != "" ]]; then
            mount -o $(cat $MNT_OPTS) "$PART" "${MNT}$MOUNT" 2>$ERR
        else
            mount "$PART" "${MNT}$MOUNT" 2>$ERR
        fi
        check_errors
        confirm_mount "${MNT}$MOUNT"
        BLK=$(lsblk -lno NAME,FSTYPE,TYPE)

        # Identify if mounted partition is "crypt" (LUKS on LVM, or LUKS alone)
        if grep -qi "crypt" <<< "$(lsblk -lno TYPE "$PART")"; then
            LUKS=1 LUKS_NAME=$(sed "s~^/dev/mapper/~~g" <<< "$PART")
            cryptblk=$(grep "lvm" <<< "$BLK" | grep -i "crypto_luks")
            crypts=$(awk '{print "/dev/mapper/"$1}' <<< "$cryptblk" | uniq)
            for i in ${crypts}; do
                if grep -q "$LUKS_NAME" <<< "$(lsblk -lno NAME "$i")"; then
                    LUKS_DEV="$LUKS_DEV cryptdevice=$i:$LUKS_NAME" LVM=1 ; break
                fi
            done
            cryptblk=$(grep "part" <<< "$BLK" | grep -i "crypto_luks")
            crypts=$(awk '{print "/dev/"$1}' <<< "$cryptblk" | uniq)
            for i in ${crypts}; do
                if grep -q "$LUKS_NAME" <<< "$(lsblk -lno NAME "$i")"; then
                    UUID=$(lsblk -lno UUID,TYPE,FSTYPE "$i" | grep "part")
                    LUKS_UUID=$(grep -i "crypto_luks" <<< "$UUID" | awk '{print $1}')
                    LUKS_DEV="$LUKS_DEV cryptdevice=UUID=$LUKS_UUID:$LUKS_NAME" break
                fi
            done
        elif grep -qi "lvm" <<< "$(lsblk -lno TYPE "$PART")"; then
            LVM=1 LV_NAME=$(sed "s~^/dev/mapper/~~g" <<< "$PART")
            cryptblk=$(grep "crypt" <<< "$BLK" | grep -i "lvm2_member")
            crypts=$(awk '{print "/dev/mapper/"$1}' <<< "$cryptblk" | uniq)
            for i in ${crypts}; do
                if grep -q "$LV_NAME" <<< "$(lsblk -lno NAME "$i")"; then
                    LUKS_NAME=$(sed 's~/dev/mapper/~~g' <<< "$i"); break
                fi
            done
            cryptblk=$(grep "part" <<< "$BLK" | grep -i "crypto_luks")
            crypts=$(awk '{print "/dev/"$1}' <<< "$cryptblk" | uniq)
            for i in ${crypts}; do
                if grep -q "$LUKS_NAME" <<< "$(lsblk -lno NAME "$i")"; then
                    UUID=$(lsblk -lno UUID,TYPE,FSTYPE "$i" | grep "part")
                    LUKS_UUID=$(grep -i "crypto_luks" <<< "$UUID" | awk '{print $1}')
                    LUKS_DEV="$LUKS_DEV cryptdevice=UUID=$LUKS_UUID:$LUKS_NAME" LUKS=1 ; break
                fi
            done
        fi
    }

    make_swap() {
        mem=$(grep MemTotal /proc/meminfo | awk '{print $2/1024}' | sed 's/\..*//')
        dlg " $_PrepMntPart " --menu "$_SelSwpBody" 0 0 7 \
            "$_Skip" "-" \
            "$_SelSwpFile" "$mem" \
            $PARTS 2> $ANS || prep_menu
        if [[ $(cat $ANS) != "$_Skip" ]]; then
            PART=$(cat $ANS)
            if [[ $PART == "$_SelSwpFile" ]]; then
                local ttl msg
                ttl=" $_SelSwpFile "
                msg="Enter size for swapfile below\n\nM = MB, G = GB"
                dlg "$ttl" --inputbox "$msg" 10 40 "${mem}M" 2> $ANS || make_swap
                tot=$(cat $ANS)
                while ! [[ ${tot: -1} =~ [MG] ]]; do
                    msg="\n$_SelSwpFile $_ErrTitle: M = MB, G = GB\n\n"
                    dlg "$ttl" --msgbox "$msg" 7 40
                    msg="\nM = MB, G = GB\n"
                    dlg "$ttl" --inputbox "$msg" 10 40 "${mem}M" 2> $ANS || make_swap
                    tot=$(cat $ANS)
                done
                log "Creating a $tot swapfile at: $MNT/swapfile"
                fallocate -l "$tot" $MNT/swapfile 2>>"$ERR"
                chmod 600 $MNT/swapfile 2>>"$ERR"
                mkswap $MNT/swapfile >/dev/null 2>>"$ERR"
                swapon $MNT/swapfile >/dev/null 2>>"$ERR"
                check_errors
            else
                if [[ $(lsblk -o FSTYPE "$PART" | grep -i "swap") != "swap" ]]; then
                    ttl=" $_PrepMntPart " msg="\nmkswap $PART\n\n"
                    if dlg "$ttl" --yesno "$msg" 0 0; then
                        log "Creating swap partition: $PART"
                        mkswap "$PART" >/dev/null 2>>"$ERR"
                    else
                        mount_parts
                    fi
                fi
                log "Mounting swap partition: $PART"
                swapon "$PART" >/dev/null 2>>"$ERR"
                check_errors
                PARTS=$(sed "s~${PART} [0-9]*[G-M]~~" <<< "$PARTS")
                PARTS=$(sed "s~${PART} [0-9]*\.[0-9]*[G-M]~~" <<< "$PARTS" | sed s~${PART}$' -'~~)
                ((NUM_PARTS--))
            fi
        fi
    }

    MOUNT=""
    local ttl msg
    ttl=" $_PrepMntPart "
    msg="$_WarnMount1 '$_Skip' $_WarnMount2"
    dlg "$ttl" --msgbox "$msg" 0 0
    lvm_detect
    INC_PART='part\|lvm\|crypt'
    umount_parts
    find_parts
    msg="$_SelRootBody"
    dlg "$ttl" --menu "$msg" 0 0 7 $PARTS 2>$ANS || prep_menu
    PART=$(cat $ANS)
    ROOT_PART=$(cat $ANS)
    log "Setting root partition as $ROOT_PART"
    choose_fs
    mnt_chosen
    make_swap

    # efi partition
    if [[ $SYSTEM == "UEFI" ]]; then
        msg="$_SelUefiBody"
        dlg "$ttl" --menu "$msg" 0 0 7 $PARTS 2>$ANS || prep_menu
        PART=$(cat $ANS)
        EFI_PART=$(cat $ANS)
        log "Setting EFI partition as $EFI_PART"
        if grep -q 'fat' <<< "$(fsck -N "$PART")"; then
            msg="$_FormUefiBody $PART $_FormUefiBody2"
            if ! dlg "$ttl" --yesno "$msg" 0 0; then
                log "Formatting $PART with 'mkfs.vfat -F32'"
                mkfs.vfat -F32 "$PART" >/dev/null 2>$ERR
            fi
        else
            log "Formatting $PART with 'mkfs.vfat -F32'"
            mkfs.vfat -F32 "$PART" >/dev/null 2>$ERR
        fi
        check_errors
        log "Mounting $PART to $MNT/$EFI_MNT"
        mkdir -p $MNT/$EFI_MNT && mount $PART $MNT/$EFI_MNT 2>$ERR
        check_errors
        confirm_mount $MNT/$EFI_MNT
    fi

    if ! grep -q "shutdown" <<< "$HOOKS"; then
        HOOKS="$HOOKS shutdown"
    fi

    # remaining partitions
    while (( $NUM_PARTS > 0 )); do
        msg="$_ExtPartBody"
        ttl=" $_PrepMntPart "
        dlg "$ttl" --menu "$msg" 0 0 7 "$_Done" "-" $PARTS 2>$ANS || prep_menu
        PART=$(cat $ANS)
        if [[ $PART == "$_Done" ]]; then
            break; main_menu
        else
            MOUNT=""
            choose_fs
            if [[ $SYSTEM == "UEFI" ]]; then
                MNT_EXAMPLES="/home /var"
            else
                MNT_EXAMPLES="/boot /home /var"
            fi
            ttl=" $_PrepMntPart $PARTITON "
            msg="${_ExtPartBody1}$MNT_EXAMPLES\n"
            dlg "$ttl" --inputbox "$msg" 0 0 "/" 2>$ANS || prep_menu
            MOUNT=$(cat $ANS)
            while [[ ${MOUNT:0:1} != "/" || ${#MOUNT} -le 1 || $MOUNT =~ \ |\' ]]; do
                msg="${_ExtPartBody1}$MNT_EXAMPLES\n"
                dlg " $_ErrTitle " --msgbox "$_ExtErrBody" 0 0
                dlg "$ttl" --inputbox "$msg" 0 0 "/" 2>$ANS || prep_menu
                MOUNT=$(cat $ANS)
            done
            log "Mounting $PART as $MOUNT"
            mnt_chosen
            if [[ $MOUNT == "/usr" ]]; then
                ! grep -q "usr" <<< "$HOOKS" && HOOKS="$HOOKS usr"
            fi
            if [[ $MOUNT == "/boot" ]]; then
                grep -q "lvm" <<< "$(lsblk -lno TYPE "$PART")" && LVM_SEP_BOOT=2 || LVM_SEP_BOOT=1
            fi
            ((NUM_PARTS--))
        fi
    done
}

######################################################################
##               Encryption (dm_crypt) Functions                    ##
######################################################################

luks_password() {
    local msg msg2
    msg="$_LuksPassBody"
    msg2="$_PassNUsrBody2 $LUKS_ROOT_NAME"
    dlg " $_PrepLUKS " --clear --insecure --passwordbox "$msg" 10 40 2>$ANS || prep_menu
    PASSWD=$(cat $ANS)
    dlg " $_PrepLUKS " --clear --insecure --passwordbox "$msg2" 8 40 2>$ANS || prep_menu
    PASSWD2=$(cat $ANS)
    if [[ $PASSWD != "$PASSWD2" ]]; then
        dlg " $_ErrTitle " --msgbox "$_PassErrBody" 10 40
        luks_password
    else
        LUKS_PASSWD="$PASSWD"
    fi
}

luks_open() {
    local ttl msg def
    LUKS_ROOT_NAME=""
    INC_PART='part\|crypt\|lvm'
    umount_parts
    find_parts
    ttl=" $_LuksOpen " msg="$_LuksMenuBody" def="cryptroot"
    dlg "$ttl" --menu "$msg" 10 50 7 $PARTS 2>$ANS || luks_menu
    PART=$(cat $ANS)
    msg="$_LuksOpenBody"
    dlg "$ttl" --inputbox "$msg" 10 50 "$def" 2>$ANS || luks_menu
    LUKS_ROOT_NAME=$(cat $ANS)
    luks_password
    msg="${_LuksWaitBody} ${LUKS_ROOT_NAME}$_LuksWaitBody2 ${PART}\n\n"
    dlg " $_LuksOpen " --infobox "$msg" 10 50
    echo "$PASSWD" | cryptsetup open --type luks "$PART" "$LUKS_ROOT_NAME" 2>$ERR
    check_errors
    luks_show
}

luks_setup() {
    local def msg ttl
    modprobe -a dm-mod dm_crypt
    INC_PART='part\|lvm'
    umount_parts
    find_parts
    ttl=" $_LuksEncrypt "
    msg="$_LuksEncryptBody"
    dlg "$ttl" --menu "$msg" 12 50 7 $PARTS 2>$ANS || luks_menu
    PART=$(cat $ANS)
    msg="$_LuksOpenBody"
    def="cryptroot"
    dlg "$ttl" --inputbox "$msg" 12 50 "$def" 2>$ANS || luks_menu
    LUKS_ROOT_NAME=$(cat $ANS)
    luks_password
}

luks_default() {
    luks_setup
    local msg="$_LuksWaitBody ${LUKS_ROOT_NAME}$_LuksWaitBody2 $PART\n\n"
    dlg " $_LuksEncrypt " --infobox "$msg" 0 0
    echo "$PASSWD" | cryptsetup -q luksFormat "$PART" 2>$ERR
    echo "$PASSWD" | cryptsetup open "$PART" "$LUKS_ROOT_NAME" 2>>$ERR
    check_errors
    luks_show
}

luks_key() {
    local msg ttl def
    luks_setup
    msg="$_LuksCipherKey"
    ttl=" $_PrepLUKS "
    def="-s 512 -c aes-xts-plain64"
    dlg "$ttl" --inputbox "$msg" 0 0 "$def" 2> $ANS || luks_menu
    msg="$_LuksWaitBody ${LUKS_ROOT_NAME}$_LuksWaitBody2 $PART\n\n"
    dlg " $_LuksEncryptAdv " --infobox "$msg" 0 0
    echo "$PASSWD" | cryptsetup -q "$(cat $ANS)" luksFormat "$PART" 2>$ERR
    echo "$PASSWD" | cryptsetup open "$PART" "$LUKS_ROOT_NAME" 2>>$ERR
    check_errors
    luks_show
}

luks_show(){
    echo -e "$_LuksEncryptSucc" >/tmp/.devlist
    lsblk -o NAME,TYPE,FSTYPE,SIZE "$PART" | grep "part\|crypt\|NAME\|TYPE\|FSTYPE\|SIZE" >>/tmp/.devlist
    dlg " $_LuksEncrypt " --textbox /tmp/.devlist 0 0
    luks_menu
}

luks_menu() {
    local msg="${_LuksMenuBody}${_LuksMenuBody2}${_LuksMenuBody3}"
    dlg " $_PrepLUKS " --menu "$msg" 0 0 4 \
        "$_LuksOpen"       "cryptsetup open --type luks" \
        "$_LuksEncrypt"    "cryptsetup -q luksFormat" \
        "$_LuksEncryptAdv" "cryptsetup -q -s -c luksFormat" \
        "$_Back" "-" 2> $ANS
    case "$(cat $ANS)" in
        "$_LuksOpen") luks_open ;;
        "$_LuksEncrypt") luks_default ;;
        "$_LuksEncryptAdv") luks_key ;;
        *) prep_menu
    esac
    luks_menu
}

######################################################################
##               Logical Volume Management Functions                ##
######################################################################

lvm_detect() {
    LVM_PV=$(pvs -o pv_name --noheading 2>/dev/null)
    LV_VG=$(vgs -o vg_name --noheading 2>/dev/null)
    LV=$(lvs -o vg_name,lv_name --noheading --separator - 2>/dev/null)
    if [[ $LV && $LV_VG && $LVM_PV ]]; then
        dlg " $_PrepLVM " --infobox "$_LvmDetBody" 0 0
        modprobe dm-mod 2>$ERR
        check_errors
        vgscan >/dev/null 2>&1
        vgchange -ay >/dev/null 2>&1
    fi
}

lvm_show_vg() {
    local msg ttl
    VG_LIST=""
    list=$(lvs --noheadings | awk '{print $2}' | uniq)
    for i in $list; do
        size=$(vgdisplay "$i" | grep -i "vg size" | awk '{print $3$4}')
        VG_LIST="$VG_LIST $i $size"
    done
    if [[ $VG_LIST == "" ]]; then
        dlg " $_ErrTitle " --msgbox "$_LvmVGErr" 0 0
        lvm_menu
    fi
    ttl=" $_PrepLVM "
    msg="$_LvmSelVGBody"
    dlg "$ttl" --menu "$msg" 0 0 5 $VG_LIST 2>$ANS || lvm_menu
}

lvm_create() {
    check_lv_size() {
        local lv=$((${#LV_SIZE} - 1))
        [[ ${#LV_SIZE} -eq 0 || ${LV_SIZE:0:1} -eq 0 ]] && ERR_SIZE=1 || ERR_SIZE=0
        if [[ $ERR_SIZE -eq 0 ]]; then
            for ((i=0; i<lv; i++)); do
                [[ ${LV_SIZE:$i:1} != [0-9] ]] && ERR_SIZE=1 && break
            done
        fi
        if [[ $ERR_SIZE -eq 0 ]]; then
            LV_SIZE_TYPE=${LV_SIZE:$lv:1}
            case $LV_SIZE_TYPE in
                m|M|g|G) ERR_SIZE=0 ;;
                *) ERR_SIZE=1
            esac
        fi
        if [[ $ERR_SIZE -eq 0 ]]; then
            s=${LV_SIZE:0:$lv}
            case $LV_SIZE_TYPE in
                G|g) [[ $((s * 1000)) -ge $VG_MB ]] && ERR_SIZE=1 || VG_MB=$((VG_MB - $((s * 1000)))) ;;
                M|m) [[ ${LV_SIZE:0:$lv} -ge $VG_MB ]] && ERR_SIZE=1 || VG_MB=$((VG_MB - s)) ;;
                *) ERR_SIZE=1
            esac
        fi
    }

    LV_VG=""
    VG_PARTS=""
    VG_MB=0
    INC_PART='part\|crypt'
    umount_parts
    find_parts
    PARTS=$(sed 's/M\|G\|T/& off/g' <<< "$PARTS")
    local msg="$_LvmNameVgBody"
    local ttl=" $_LvmCreateVG "
    dlg "$ttl" --inputbox "$msg" 0 0 "" 2> $ANS || prep_menu
    LV_VG=$(cat $ANS)
    has=$(grep -q "$LV_VG" <<< "$(lsblk)")
    while [[ ${LV_VG:0:1} == "/" || ${#LV_VG} -eq 0 || $LV_VG =~ \ |\' || $has ]]; do
        dlg "$_ErrTitle" --msgbox "$_LvmNameVgErr" 0 0
        dlg "$ttl" --inputbox "$msg" 0 0 "" 2>$ANS || prep_menu
        LV_VG=$(cat $ANS)
    done
    msg="$_LvmPvSelBody $_UseSpaceBar"
    dlg "$ttl" --checklist "$msg" 0 0 7 $PARTS 2> $ANS || prep_menu
    [[ $(cat $ANS) != "" ]] && VG_PARTS=$(cat $ANS) || prep_menu
    msg="${_LvmPvConfBody1}: ${LV_VG}\n\n$_LvmPvConfBody2${VG_PARTS}"
    if dlg "$ttl" --yesno "$msg" 0 0; then
        msg="$_LvmPvActBody1${LV_VG}.$_PlsWaitBody"
        dlg "$ttl" --infobox "$msg" 10 50
        sleep 1 && vgcreate -f "$LV_VG" "$VG_PARTS" >/dev/null 2>>"$ERR"
        check_errors
        VG_SIZE=$(vgdisplay "$LV_VG" | grep 'VG Size' | sed 's/\..*//' | sed 's/[^0-9]*//g')
        VG_SIZE_TYPE=$(vgdisplay "$LV_VG" | grep 'VG Size' | awk '{print $4}')
        [[ ${VG_SIZE_TYPE:0:1} == "G" ]] && VG_MB=$((VG_SIZE * 1000)) || VG_MB=$VG_SIZE
        msg="${_LvmPvDoneBody1}'$LV_VG' $_LvmPvDoneBody2\n\n($VG_SIZE $VG_SIZE_TYPE)"
        dlg "$ttl" --msgbox "$msg" 8 50
    else
        lvm_menu
    fi
    msg="$_LvmLvNumBody1 $LV_VG. $_LvmLvNumBody2"
    dlg "$ttl" --radiolist "$msg" 0 0 9 \
        "1" "-" off "2" "-" off "3" "-" off  "4" "-" off \
        "5" "-" off "6" "-" off "7" "-" off "8" "-" off "9" "-" off 2>$ANS
    [[ $(cat $ANS) == "" ]] && lvm_menu || NUM_LVS=$(cat $ANS)
    while [[ $NUM_LVS -gt 1 ]]; do
        ttl=" $_LvmCreateVG (LV:$NUM_LVS) "
        msg="$_LvmLvNameBody1"
        dlg "$ttl" --inputbox "$msg" 0 0 "lvol" 2> $ANS || prep_menu
        LV_NAME=$(cat $ANS)
        has=$(grep -q "$LV_NAME" <<< "$(lsblk)")
        while [[ ${LV_NAME:0:1} == "/" || ${#LV_NAME} -eq 0 || $LV_NAME =~ \ |\' || $has ]]; do
            dlg " $_ErrTitle " --msgbox "$_LvmLvNameErrBody" 0 0
            dlg "$ttl" --inputbox "$msg" 0 0 "lvol" 2> $ANS || prep_menu
            LV_NAME=$(cat $ANS)
        done
        msg="${LV_VG}: ${VG_SIZE}$VG_SIZE_TYPE (${VG_MB}MB $_LvmLvSizeBody1).$_LvmLvSizeBody2"
        dlg "$ttl" --inputbox "$msg" 0 0 "" 2> $ANS || prep_menu
        LV_SIZE=$(cat $ANS)
        check_lv_size
        while [[ $ERR_SIZE -eq 1 ]]; do
            dlg " $_ErrTitle " --msgbox "$_LvmLvSizeErrBody" 0 0
            dlg "$ttl" --inputbox "$msg" 0 0 "" 2> $ANS || prep_menu
            LV_SIZE=$(cat $ANS)
            check_lv_size
        done
        lvcreate -L "$LV_SIZE" "$LV_VG" -n "$LV_NAME" 2>>"$ERR"
        check_errors
        msg="$_Done LV $LV_NAME ($LV_SIZE) $_LvmPvDoneBody2."
        dlg "$ttl" --msgbox "$msg" 0 0
        NUM_LVS=$((NUM_LVS - 1))
    done
    ttl=" $_LvmCreateVG (LV:$NUM_LVS) "
    msg="$_LvmLvNameBody1 $_LvmLvNameBody2 (${VG_MB}MB)."
    dlg "$ttl" --inputbox "$msg" 0 0 "lvol" 2> $ANS || prep_menu
    LV_NAME=$(cat $ANS)
    has=$(grep -q "$LV_NAME" <<< "$(lsblk)")
    while [[ ${LV_NAME:0:1} == "/" || ${#LV_NAME} -eq 0 || $LV_NAME =~ \ |\' || $has ]]; do
        dlg " $_ErrTitle " --msgbox "$_LvmLvNameErrBody" 0 0
        dlg "$ttl" --inputbox "$msg" 0 0 "lvol" 2> $ANS || prep_menu
        LV_NAME=$(cat $ANS)
    done
    lvcreate -l +100%FREE "$LV_VG" -n "$LV_NAME" 2>>"$ERR"
    check_errors
    ((NUM_LVS--))
    LVM=1
    ttl=" $_LvmCreateVG "
    msg="$_LvmCompBody"
    dlg "$ttl" --yesno "$msg" 0 0 && show_devices || lvm_menu
}

lvm_del_vg() {
    lvm_show_vg
    if dlg " $_LvmDelVG " --yesno "$_LvmDelQ" 0 0; then
        vgremove -f "$(cat $ANS)" >/dev/null 2>&1
    fi
    lvm_menu
}

lvm_del_all() {
    LVM_PV=$(pvs -o pv_name --noheading 2>/dev/null)
    LV_VG=$(vgs -o vg_name --noheading 2>/dev/null)
    LV=$(lvs -o vg_name,lv_name --noheading --separator - 2>/dev/null)
    if dlg " $_LvMDelAll " --yesno "$_LvmDelQ" 0 0; then
        for i in $LV; do lvremove -f "/dev/mapper/$i" >/dev/null 2>&1; done
        for i in $LV_VG; do vgremove -f "$i" >/dev/null 2>&1; done
        for i in $LVM_PV; do pvremove -f "$i" >/dev/null 2>&1; done
        LVM=0
    fi
    lvm_menu
}

lvm_menu() {
    dlg " $_PrepLVM " --infobox "$_PlsWaitBody" 0 0
    sleep 1
    lvm_detect
    dlg " $_PrepLVM " --menu "$_LvmMenu" 0 0 4 \
        "$_LvmCreateVG" "vgcreate -f, lvcreate -L -n" \
        "$_LvmDelVG"    "vgremove -f" \
        "$_LvMDelAll"   "lvrmeove, vgremove, pvremove -f" \
        "$_Back" "-" 2> $ANS
    case "$(cat $ANS)" in
        "$_LvmCreateVG") lvm_create  ;;
        "$_LvmDelVG")    lvm_del_vg  ;;
        "$_LvMDelAll")   lvm_del_all ;;
        *)               prep_menu
    esac
}

######################################################################
##                      Installation Functions                      ##
######################################################################

install_system() {
    if [[ ! -e $MNT/etc ]]; then
        local ttl="Begin System Unpacking"
        local msg="This will unpack $DIST to the partition chosen during mounting:\n$ROOT_PART"
        if [[ $SYSTEM == "UEFI" ]]; then
            msg="$msg\n\nThe bootloader will be written to the system EFI partition:\n$EFI_PART"
        else
            msg="$msg\n\nBIOS (legacy boot) systems like this can install the bootloader on any of the available partitions.
            \nDuring the unpack you will be asked which partition to install it on.
            \nThe recommended and simple approach is to choose the root (/) partition:\n$ROOT_PART"
        fi
        msg="$msg\n\nDo you want to continue?"
        if dlg "$ttl" --yesno "$msg" 0 0; then
            log "Unpacking system to $ROOT_PART"
            unpack_image
        else
            main_menu
            return 0
        fi
    fi
    clear
    log "Generating FSTAB at $MNT/etc/fstab"
    genfstab -U -p $MNT > $MNT/etc/fstab 2> $ERR
    check_errors
    [[ -f $MNT/swapfile ]] && sed -i "s/\\${MNT}//" $MNT/etc/fstab
    run_mkinitcpio
    install_boot
    config_menu
}

unpack_image() {
    clear
    rsync -a --progress $SYS_IMG $MNT/ 2>$ERR
    check_errors
    local files
    local autostart="$MNT/etc/skel/.config/openbox/autostart"
    files=(archlabs-installer etc/sudoers.d/g_wheel
    etc/mkinitcpio-archiso.conf usr/bin/install-al
    etc/polkit-1/rules.d/49-nopasswd_global.rules)
    for f in "${files[@]}"; do rm -rf $MNT/$f ; done
    find $MNT/usr/lib/initcpio -name archiso* -type f -exec rm '{}' \;
    sed -i '/al-hello/ c sleep 10; termite --exec=/usr/bin/al-hello &' $autostart
    sed -i 's|#$HOME/.config/setup &|$HOME/.config/setup &|g' $autostart
    sed -i 's/volatile/auto/g' $MNT/etc/systemd/journald.conf
    cp -f $KERN_IMG $MNT/boot/vmlinuz-linux 2>$ERR
    check_errors
    [[ -e /tmp/keyboard ]] && cp -f /tmp/keyboard $MNT/etc/default/
    [[ -e /tmp/vconsole.conf ]] && cp -f /tmp/vconsole.conf $MNT/etc/
    [[ -e /tmp/01-keyboard.conf ]] && cp -f /tmp/01-keyboard.conf $MNT/etc/X11/xorg.conf.d/
    [[ -e /etc/resolv.conf ]] && cp -f /etc/resolv.conf $MNT/etc/
    if [[ -d /etc/NetworkManager/system-connections ]]; then
        for f in etc/NetworkManager/system-connections/*; do
            [[ -e "$MNT/$f" ]] && continue || cp -rf "/$f" "$MNT/"
        done
    fi
    reflector --score 40 --fastest 10 --sort rate --save $MNT/etc/pacman.d/mirrorlist --verbose
    chr "pacman -Syu --noconfirm"
    chr "pacman -S iputils --noconfirm"
    chr "pacman -S base-devel git --needed --noconfirm"
}

install_boot() {
    grub_configuration() {
        local CFG="$MNT/etc/default/grub"
        log "Updating $CFG"
        sed -i "s/GRUB_DISTRIBUTOR=.*/GRUB_DISTRIBUTOR=\"${DIST}\"/g" $CFG
        if [[ $LUKS -eq 1 ]]; then
            if [[ $LUKS_DEV ]]; then
                log "Adding GRUB_CMDLINE_LINUX=$LUKS_DEV"
                sed -i "s~GRUB_CMDLINE_LINUX=\"\"~GRUB_CMDLINE_LINUX=\"${LUKS_DEV}\"~g" $CFG 2>$ERR
                check_errors
            fi
            log "Adding GRUB_ENABLE_CRYPTODISK=y"
            sed -i "s/#GRUB_ENABLE_CRYPTODISK=y/GRUB_ENABLE_CRYPTODISK=y/g" $CFG 2>$ERR
            check_errors
        fi
        if [[ $SYSTEM == "BIOS" ]]; then
            if ([[ $LVM -eq 1 ]] && [[ $LVM_SEP_BOOT -eq 0 ]]) || [[ $LVM_SEP_BOOT -eq 2 ]]; then
                log "Adding GRUB_PRELOAD_MODULES=lvm"
                sed -i "s/GRUB_PRELOAD_MODULES=.*/GRUB_PRELOAD_MODULES=\"lvm\"/g" $CFG 2>$ERR
                check_errors
            fi
        fi
    }

    bios_bootloader() {
        select_device "grub"
        grub_configuration
        log "Installing Grub in BIOS mode on device: $DEVICE"
        chr "grub-install --bootloader-id=$DIST --recheck --force $DEVICE" 2>$ERR
        check_errors
    }

    uefi_bootloader() {
        if grep -q "/sys/firmware/efi/efivars" <<< "$(mount)"; then
            mount -t efivarfs efivarfs /sys/firmware/efi/efivars &>/dev/null
            chr "mount -t efivarfs efivarfs /sys/firmware/efi/efivars" &>/dev/null
        fi
        grub_configuration
        log "Installing Grub for UEFI"
        chr "grub-install --bootloader-id=$DIST --recheck --force" 2>$ERR
        check_errors
        local bd drs
        bd="Boot"
        drs=$(find $MNT/$EFI_MNT/EFI -maxdepth 1 -mindepth 1 -type d)
        for i in $drs; do
            grep -qi "boot" <<< "$(basename $i)" && { bd="$(basename $i)"; break; }
        done
        log "Copying $MNT/$EFI_MNT/EFI/$DIST/grubx64.efi -> $MNT/$EFI_MNT/EFI/$bd/bootx64.efi"
        mkdir -p "$MNT/$EFI_MNT/EFI/$bd"
        chr "cp -fa /$EFI_MNT/EFI/$DIST/grubx64.efi /$EFI_MNT/EFI/$bd/grubx64.efi"
        chr "cp -fa /$EFI_MNT/EFI/$bd/grubx64.efi /$EFI_MNT/EFI/$bd/bootx64.efi"
    }

    chr "export PATH=/usr/local/sbin:/usr/local/bin:/usr/bin:/bin:/usr/bin/core_perl"
    if [[ $BOOTD != "True" ]]; then
        mkdir -p $MNT/run/udev
        mount -o bind /run/udev $MNT/run/udev
        [[ $SYSTEM == "BIOS" ]] && bios_bootloader || uefi_bootloader
        BOOTD="True"
    fi
    chr "os-prober" &>/dev/null
    chr "grub-mkconfig -o /boot/grub/grub.cfg" 2>$ERR
    check_errors
    log "Bootloader Install Finished"
    if [[ $SYSTEM != "UEFI" ]]; then
        msg="Bootloader installation completed successfully"
        dlg " $_InstBootldr " --msgbox "$msg" 0 50
    fi
}

run_mkinitcpio() {
    clear
    log "Running mkinitcpio"
    local conf="$MNT/etc/mkinitcpio.conf"
    if [[ $LVM -eq 1 && $LUKS -eq 0 ]]; then
        sed -i 's/block filesystems/block lvm2 filesystems/g' $conf 2>$ERR
    elif [[ $LVM -eq 1 && $LUKS -eq 1 ]]; then
        sed -i 's/block filesystems/block encrypt lvm2 filesystems/g' $conf 2>$ERR
    elif [[ $LVM -eq 0 && $LUKS -eq 1 ]]; then
        sed -i 's/block filesystems/block encrypt filesystems/g' $conf 2>$ERR
    fi
    check_errors
    if [[ $LUKS_PASSWD && $LUKS_UUID ]]; then
        local dev
        dev=$(lsblk -lno NAME,UUID,TYPE | grep "part")
        dev="/dev/$(grep "$LUKS_UUID" <<< "$dev" | awk '{print $1}')"
        log "Setting up single password decryption\n\nCreating keyfile: /crypto_keyfile.bin"
        chr "dd bs=512 count=8 if=/dev/urandom of=/crypto_keyfile.bin"
        chr "chmod 000 /crypto_keyfile.bin"
        chr "echo '$LUKS_PASSWD' | cryptsetup luksAddKey $dev /crypto_keyfile.bin"
        sed -i 's/FILES=()/FILES=(\/crypto_keyfile.bin)/g' $conf
    fi
    [[ $HOOKS ]] && sed -i "s/keyboard fsck/keyboard ${HOOKS} fsck/g" $conf
    chr "mkinitcpio -p linux" 2>$ERR
    check_errors
}

######################################################################
##                          Menu Interfaces                         ##
######################################################################

main_menu() {
    if [[ $MENU == "prep" && $HL -eq 7 ]]; then
        MENU="main" MH=3
        check_mount && install_system
    fi
    if [[ ! -e $MNT/etc && $MENU != "main" ]]; then
        MENU="main" MH=1
    elif (( $MH < 5 )); then
        ((MH++))
    fi
    dlg " $_MMTitle " --default-item $MH --menu "$_MMBody" 20 60 5 \
        "1" "$_PrepMenuTitle" \
        "2" "$_InstBseMenuTitle" \
        "3" "$_ConfBseMenuTitle" \
        "4" "$_SeeConfOptTitle" \
        "5" "$_Done" 2> $ANS
    MH=$(cat $ANS)
    if (( $MH == 2 )) && ! check_mount; then
        return 1
    elif (( $MH >= 3 && $MH <= 4 )) && ! (check_mount && check_base); then
        return 1
    fi
    case $MH in
        1) prep_menu ;;
        2) install_system ;;
        3) config_menu ;;
        4) edit_configs ;;
        *)
            if dialog ${BT[@]} --yesno "$_CloseInstBody" 8 45; then
                umount_parts
                exit 0
            else
                return 0
            fi
    esac
    return 0
}

prep_menu() {
    if [[ $MENU != "prep" ]]; then
        MENU="prep" HL=1
    elif (( $HL < 7 )); then
        ((HL++))
    fi
    (( $HL == 7 )) && { main_menu; return 0; }
    dlg " $_PrepMenuTitle " --default-item $HL --menu "$_PrepMenuBody" 17 60 7 \
        "1" "$_PrepKBLayout" \
        "2" "$_DevShowOpt" \
        "3" "$_PrepPartDisk" \
        "4" "$_PrepLUKS" \
        "5" "$_PrepLVM" \
        "6" "$_PrepMntPart" \
        "7" "$_Back" 2> $ANS || return 0
    HL=$(cat $ANS)
    case $HL in
        1) set_keymap ;;
        2) show_devices ;;
        3) umount_parts; select_device; create_parts ;;
        4) luks_menu ;;
        5) lvm_menu ;;
        6) mount_parts ;;
        *) return 0
    esac
    prep_menu
}

config_menu() {
    chr "export PATH=/usr/local/sbin:/usr/local/bin:/usr/bin:/usr/bin/core_perl"
    if [[ $MENU != "config" ]]; then
        MENU="config" HL=1
    elif (( $HL < 5 )); then
        ((HL++))
    fi
    (( $HL == 5 )) && { main_menu; return 0; }
    local ttl=" $_ConfBseMenuTitle "
    dlg "$ttl" --default-item $HL --menu "$_ConfBseBody" 14 60 5 \
        "1" "$_ConfBseHost" \
        "2" "$_ConfBseSysLoc" \
        "3" "$_ConfUsrRoot" \
        "4" "$_ConfUsrNew" \
        "5" "$_Back" 2> $ANS || return 0
    HL=$(cat $ANS)
    case $HL in
        1) set_hostname ;;
        2) set_locale ;;
        3) root_password ;;
        4) create_user ;;
        *) return 0
    esac
    config_menu
}

edit_configs() {
    if [[ $MENU != "edit" ]]; then
        MENU="edit" HL=1
    elif (( $HL < 11 )); then
        ((HL++))
    fi
    dlg " $_SeeConfOptTitle " --default-item $HL --menu "$_SeeConfOptBody" 21 60 11 \
        "1" "keymap configs" \
        "2" "locale configs" \
        "3" "/etc/hostname" \
        "4" "/etc/hosts" \
        "5" "/etc/sudoers" \
        "6" "/etc/mkinitcpio.conf" \
        "7" "/etc/fstab" \
        "8" "/etc/crypttab" \
        "9" "/etc/default/grub" \
        "10" "/etc/pacman.conf" \
        "11" "$_Back" 2> $ANS || return 0
    HL=$(cat $ANS)
    FILE=""
    xkeyfile="$MNT/etc/X11/xorg.conf.d/01-keyboard.conf"
    case $HL in
        1) [[ -e $xkeyfile ]] && FILE="$FILE $xkeyfile"
           [[ -e $MNT/etc/vconsole.conf ]] && FILE="$MNT/etc/vconsole.conf"
           [[ -e $MNT/etc/default/keyboard ]] && FILE="$FILE $MNT/etc/default/keyboard" ;;
        2) [[ -e $MNT/etc/locale.conf ]] && FILE="$MNT/etc/locale.conf"
           [[ -e $MNT/etc/default/locale ]] && FILE="$FILE $MNT/etc/default/locale" ;;
        3) [[ -e $MNT/etc/hostname ]] && FILE="$MNT/etc/hostname" ;;
        4) [[ -e $MNT/etc/hosts ]] && FILE="$MNT/etc/hosts" ;;
        5) [[ -e $MNT/etc/sudoers ]] && FILE="$MNT/etc/sudoers" ;;
        6) [[ -e $MNT/etc/mkinitcpio.conf ]] && FILE="$MNT/etc/mkinitcpio.conf" ;;
        7) [[ -e $MNT/etc/fstab ]] && FILE="$MNT/etc/fstab" ;;
        8) [[ -e $MNT/etc/crypttab ]] && FILE="$MNT/etc/crypttab" ;;
        9) [[ -e $MNT/etc/default/grub ]] && FILE="$MNT/etc/default/grub" ;;
        10) [[ -e $MNT/etc/pacman.conf ]] && FILE="$MNT/etc/pacman.conf" ;;
        *) return 0
    esac
    if [[ $FILE ]]; then
        ([[ $DISPLAY ]] && hash geany &>/dev/null) && geany -i $FILE || vim -O $FILE
    else
        dlg " $_ErrTitle " --msgbox "$_SeeConfErrBody" 0 0
    fi
    edit_configs
}

[[ $1 == "--debug" || $1 == "-d" ]] && DBG="True" || DBG=""
select_lang
check_req
id_system
dlg " $_WelTitle $VER " --msgbox "$_WelBody" 0 0
while true; do
    main_menu
done
